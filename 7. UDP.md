![](https://velog.velcdn.com/images/alstjr971/post/226fb104-f20f-4d3c-94ef-4918d5dfb657/image.png)

그림은 TCP/IP 프로토콜 Suite(모음)의 다른 프로토콜 및 계층과 UDP와의 관계를 나타내는 그림이다.

> UDP는 응용 계층과 IP 계층 사이 전송 계층에 위치한다.

- SCTP는 일반 개발자들이 사용할 일은 잘 없으므로 TCP, UDP에 대해서만 공부해도 무방하다.

# 1️⃣ 사용자 데이터그램

UDP는 `비연결형`, `신뢰성 없는` **전송 프로토콜**이다.

- 💡`host to host` 통신 대신 `process to process` 통신을 제공하는 것 이외에는 IP 서비스에 추가되는 기능은 아무것도 없다.🔥

**🤔그럼 왜 프로세스는 UDP를 사용할까❓**

1. UDP는 최소한의 오버헤드만 사용하는 **매우 간단한 프로토콜**이다.
2. 작은 메시지를 보내고자 하고, 신뢰성에 대해 걱정하지 않는 프로세스에 UDP를 사용한다.
  - UDP를 이용하여 작은 메시지를 전송하는 것이 TCP를 사용하는 것보다 송신자와 수신자 간의 상호작용이 훨씬 적다.
  
- 만약 재전송 기능만 필요한데 TCP의 오버헤드는 너무 커 사용하기 어렵다면, UDP를 사용하고 재전송에 대한 부분을 개발자가 직접 구현해 사용하면 된다.(EX. 카카오톡)

### 사용자 데이터그램 형식

![](https://velog.velcdn.com/images/alstjr971/post/1ee453f1-ffee-48b9-84c7-a35ae5251844/image.png)

- 앞에 8바이트 헤더 부분이 이전 포스팅의 ICMP 메시지 뒤에 있던 8바이트다.

### 발신지 포트 번호

**발신지 호스트에서 데이터를 보내는 프로세스의 포트 번호**

만약 발신지 호스트가 요청을 전송하는 `Client`라면, 대부분의 경우 포트 번호는 임시 포트 번호를 사용한다.

만약 응답을 전송하는 `Server`라면, 대부분의 경우 **잘 알려진 포트 번호**를 사용한다.

> 서버인데 잘 알려진 포트 번호를 사용하지 않는 경우는❓
- 개방하지 않고, 공개하고 싶은 사람에게만 노출하고 싶은 경우


### 목적지 포트 번호

**목적지 호스트에서 데이터를 받을 프로세스의 포트 번호**

만약 목적지 호스트가 클라이언트에 의해 요청이 보내지는 `Server`라면, 대부분의 경우 포트 번호는 **잘 알려진 포트를 사용**

만약 목적지 호스트가 서버가 보낸 응답을 받는 `Client`라면, 대부분의 경우 포트 번호는 임시 포트 번호를 사용한다.

> 출발지, 목적지 호스트의 프로세스 포트 번호는 Client는 임시 번호를, Server는 잘 알려진 포트를 '주로' 사용한다.


### 전체 길이

**헤더와 데이터(payload)를 합한 사용자 데이터그램의 전체 길이**

0 ~ 65,535(2^16) 바이트 사이의 전체 길이 정의 가능

그러나 최대 길이가 65,536 바이트인 IP 데이터그램 내에 UDP 사용자 데이터그램이 포함되기 때문에, 실제 UDP의 전체 길이는 그보다 작아야 한다.

- 최소 값 : 8 -> 아무런 데이터를 포함하지 않는 경우
- 최대 값: 65,515 -> 65536 - 20 (IP 헤더의 최소 길이)

---

# 2️⃣ UDP 서비스

![](https://velog.velcdn.com/images/alstjr971/post/7601968c-b4fd-41e0-b2b4-bf2be0cf66a4/image.png)

UDP는 비연결형 서비스를 제공한다.

각각의 사용자 데이터그램은 서로 `독립적인 프로그램`이라는 것을 의미

- 그래서, 사용자 데이터그램에는 `번호`가 붙지 않는다.
- 또한, `연결 설정`과 `연결 종료` 과정이 없다.

> 이것은 각각의 사용자 데이터그램이 다른 경로를 통하여 전달될 수 있음을 의미한다.
- TCP의 경우 신뢰성/연결형 서비스이기 때문에 같은 경로로 계속 전달됨

각 데이터는 하나의 사용자 데이터그램에 들어갈 수 있을 만큼 충분히 작아야 한다
- 데이터는 65,535 -20 -8 바이트보다 작아야 함
(IP 패킷의 최대 길이 : 16비트 -> 65536 - (IP 헤더 최소 값 20) - (UDP 헤더 최소 값 8)

## 흐름 제어 X

UDP는 매우 간단한 프로토콜로, 흐름 제어 기능이 없다.
또, 윈도우 메커니즘도 없다. (TCP에 있음)

- 수신 측에서는 들어오는 메시지로 인해 오버플로우가 발생할 수 있다.

## 오류 제어 메커니즘 X

UDP에는 체크섬을 제외한 오류 제어 메커니즘이 없다.
- 메시지가 손실되거나 중복되었는지 송신자는 알 수 없다.
- 수신자가 검사합을 사용하여 오류를 감지하면, 사용자 데이터그램을 그냥 폐기한다.

> 흐름 제어와 오류 제어가 없다는 것은, UDP를 이용하는 프로세스에서 필요한 경우에 자체적으로 이러한 서비스를 제공해야 한다는 것을 의미한다.

그 대표적인 예시가 카카오톡이다. 카카오톡에서 메시지가 전송되지 않으면 내 카카오톡 화면에 `X` 표시가 나고 '재전송' 버튼이 나온다. 이는 TCP 처럼 재전송 메커니즘이 동작하지 않음을 나타내므로, UDP 프로토콜을 사용하고 있다는 것을 알 수 있다.

## 캡슐화와 역캡슐화

![](https://velog.velcdn.com/images/alstjr971/post/8485abc3-80ce-4709-8333-bf70a600bcf9/image.png)

> 캡슐화, 역캡슐화는 IP 프로토콜을 관련 포스팅해서 자주 언급했으므로 생략한다.

## 큐잉

**네트워크 장비가 동시에 여러 패킷을 수신했지만, 처리 속도나 대역폭이 한정되어 있을 때 순서를 정하고 `대기열`을 저장하는 메커니즘**

> 큐잉은 혼잡 제어, 패킷 손실 최소화 등의 목적으로 사용된다.

![](https://velog.velcdn.com/images/alstjr971/post/6d0eb8b8-c259-414f-8daf-9a451e4690c9/image.png)

✅클라이언트 프로세스

- 프로세스가 시작되면, 프로세스는 운영체제에게 포트 번호를 요청하는 `bind()` 함수를 호출한다.

그 뒤,
- 어떤 구현에서는 각 프로세스에 연계된 입력 큐와 출력 큐가 같이 생성된다.
- 어떤 구현은 입력 큐만 생성된다.

대부분의 경우, 클라이언트가 획득한 큐는 임시 포트 번호로 식별된다.
프로세스가 종료되면, 큐는 제거된다.
- 즉, 큐에 대한 식별자가 포트 번호가 되는 것

출력 큐에 오버플로우가 발생하면 수신자 측의 운영체제는 클라이언트 프로세스에게 메시지를 더 보내지 말고 기다리라고 요청한다.

메시지가 클라이언트에 도착하면 UDP는 사용자 데이터그램이 목적지 포트 번호 필드(임시 포트 번호)와 대응하는 입력 큐가 존재하는지 점검한다.

만약 큐가 존재한다면 UDP는 수신된 사용자 데이터그램을 큐의 끝에 추가하고, 없다면 사용자 데이터그램을 폐기하고 ICMP 프로토콜에게 목적지 도달 불가 메시지를 서버로 보낼 것을 요청한다.

순서대로 정리하면 다음과 같을 것이다.

| 단계 | 동작 설명                                                              |
| -- | ------------------------------------------------------------------ |
| 1  | A의 애플리케이션이 UDP 데이터 전송 요청                                           |
| 2  | A의 출력 큐가 가득 차면, A 운영체제가 애플리케이션에 **대기 요청 또는 오류 반환**                 |
| 3  | 출력 큐에 여유 생기면 B로 전송                                                 |
| 4  | B는 도착한 패킷의 **목적지 포트를 확인**하고, 해당 포트로 바인딩된 **입력 큐가 있는지 확인**          |
| 5  | 입력 큐 있으면 → 큐 끝에 추가<br>없으면 → 패킷 드롭 + **B가 ICMP 오류 메시지 생성 후 A에게 전송** |

✅서버 프로세스

서버 측에서 큐를 생성하는 메커니즘은 조금 다르다.

가장 간단한 경우, 서버는 수행되기 시작할 때 잘 알려진 포트 번호를 사용해 입력 큐와 출력 큐를 요청한다.

서버에 메시지가 도착하면, UDP는, 사용자 데이터그램의 목적지 포트 번호 필드에 지정된 포트 번호에 대한 입력 큐가 있는지 점검한다.

만약 그러한 큐가 있다면 UDP는 수신한 사용자 데이터그램을 큐의 끝에 추가하고, 없거나 오버플로우가 발생하면 폐기하고 ICMP 프로토콜에게 목적지 도달 불가 메시지를 클라이언트에게 보낼 것을 요청한다.


## 다중화와 역다중화

![](https://velog.velcdn.com/images/alstjr971/post/10cbf07c-25ee-41e5-b610-02e6ffd94610/image.png)

> TCP/IP 프로토콜을 수행하고 있는 호스트에서 UDP는 하나 뿐이지만, UDP 서비스를 사용하기 원하는 프로세스는 여러 개일 수 있다.

✅다중화

- 다대일의 관계
- UDP는 프로세스마다 할당된 포트 번호에 의해 구분되는 서로 다른 프로세스로부터 메시지를 수신
- UDP는 헤더를 추가한 후, IP에게 사용자 데이터그램을 전달

✅역다중화

- 일대다의 관계
- UDP는 IP로 부터 사용자 데이터그램을 수신
- 오류를 점검하고 이상이 없다면 헤더를 제거한 뒤 포트 번호에 의거해 각 메시지를 적절한 프로세스로 배달


# 3️⃣ UDP 패키지

> UDP가 어떻게 UDP 패킷을 송신하고 수신하는지 이해하기 위해, UDP 패키지의 간단한 버전을 보자.

![](https://velog.velcdn.com/images/alstjr971/post/50b89f23-fe2b-42ef-968a-56b5d3288fd6/image.png)

UDP 패키지는 5개의 구성 요소를 가진다.

**1. 제어 블록 테이블**
![](https://velog.velcdn.com/images/alstjr971/post/62dd7540-fcfa-406e-b556-72372f65d7b9/image.png)

- 열린 포트를 추적하는데 사용한다.

프로세스가 어떤 포트에 바인딩 되어 있고 사용 중인지 추적


**2. 입력 큐**

- 각각의 프로세스 당 하나의 입력 큐가 배정된다.

위 그림은 출력 큐를 사용하지 않는 예시다.

**3. 제어 블록 모듈**

- 제어 블록 테이블의 관리를 담당한다

제어 블록 테이블의 생성/조회/갱신/삭제 등 전체 생애 주기를 관리


**4. 입력 모듈**

- IP로부터 사용자 데이터그램을 수신
- 데이터그램을 큐에 삽입하기 위해 제어 블록 테이블의 정보를 활용
- 큐에 삽입을 실패하면, ICMP 메시지를 생성

**5. 출력 모듈**

- 사용자 데이터그램을 생성하고 전송하는 임무를 담당

---

`예시`

![](https://velog.velcdn.com/images/alstjr971/post/5ed66742-c950-460c-bca5-a9de5469b68d/image.png)

목적지 포트 번호가 52,012인 사용자 데이터그램이 도착하였다.

입력 모듈은 이 포트 번호를 탐색하여 찾아낸다.
- 제어 블록 테이블 탐색

이 포트에는 큐 번호 38이 배정되어 있다. 따라서 포트 번호가 사용 중인 것을 알 수 있다.

입력 모듈은 데이터를 38번 큐에 보낸다.

(제어 블록 테이블은 변하지 않는다.)

![](https://velog.velcdn.com/images/alstjr971/post/45cf084e-e9e9-4660-8856-2f7584e7d609/image.png)

몇 초 후, 프로세스가 시작된다 -> 소켓 생성

이 프로세스는 운영체제에게 포트 번호를 요청(bind)하고, 52,014를 할당 받는다.

프로세스는 자신의 PID(4,978)와 포트 번호를 제어 블록 모듈에 보내 테이블 내에 엔트리를 생성한다.

![](https://velog.velcdn.com/images/alstjr971/post/509fc5da-7751-4cce-863d-f9fb9137fc8a/image.png)

52,011 포트에 사용자 데이터그램이 도착한다.

입력 모듈은 테이블을 검사하여 이 목적지를 위한 큐가 아직 배당되지 않았음을 알게 된다.
- 해당 패킷이 이 목적지로 온 첫 번째 사용자 데이터그램이기 때문

모듈은 43번 큐를 생성한다.

![](https://velog.velcdn.com/images/alstjr971/post/89cc9ad0-0320-4b43-8b22-6e35ebd260a8/image.png)

몇 초 후, 52,222 포트에 사용자 데이터그램이 도착한다.

입력 모듈이 테이블을 검사한 결과, 이 목적지를 위한 엔트리를 발견하지 못한다.
- 프로세스가 실행 중이지 않음

사용자 데이터그램은 폐기되고, 발신지에 목적지 도달 불가 ICMP 오류 메시지를 요청한다.
