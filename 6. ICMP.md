IP 프로토콜은 오류 보고와 오류 정정 메커니즘이 없는 `비연결형`, `비신뢰성` 프로토콜이다.

그런데, 만약 통신 중 잘못된 일이 발생하면 어떻게 될까?

예를 들어 최종 목적지를 향항 중간 라우터를 찾을 수 없다거나, 수명 필드가 0이 되어 라우터가 데이터그램을 폐기하면 어떻게 될까?

> 이들은 오류가 발생하였는데도 불구하고 IP 프로토콜이 원래의 호스트에게 통보할 메커니즘을 갖고 있지 않은 상황의 예제다.

![](https://velog.velcdn.com/images/alstjr971/post/d9e59826-d0b0-4b62-bd87-7418230849a6/image.png)

- 그림에서 ICMP 가 IP 보다 상대적으로 위에 위치하는 이유는 ICMP 프로토콜은 결국 IP 계층을 거쳐서 이뤄지기 때문


# ICMP 캡술화

**ICMP는 네트워크 계층 프로토콜이다.**

그러나, 이 프로토콜의 메시지는 예상과는 달리 직접 `데이터링크 계층`으로 전달되지 않는다.

대신, 메시지는 하위 계층으로 가기 전에 IP 데이터그램 안에 캡슐화된다.
- 물리적 네트워크를 벗어날 수 있어야 하기 때문이다.
- 목적지의 IP 주소를 유지한 채, IP 패킷에 ICMP 메시지를 캡슐화 하는 것

![](https://velog.velcdn.com/images/alstjr971/post/b522441e-7c7b-47ce-95c4-d66267f3a251/image.png)

> 즉, ICMP 메시지는 데이터 링크 계층으로 '직접' 내려가지 않고, IP 패킷에 포함되어 전달된다.


---

`메시지 형식`

![](https://velog.velcdn.com/images/alstjr971/post/9354daae-7ea3-460e-aabc-9a3252853a13/image.png)

**ICMP 메시지는 두 개의 카테고리로 분류된다.**

1. 오류 보고 메시지
2. 질의 메시지

- 오류 보고 메시지는 라우터나 호스트가 IP 패킷을 처리하는 도중에 탐지되는 문제를 보고

- 질의 메시지는 쌍으로 생성되는데, 호스트나 네트워크 관리자가 라우터나 다른 호스트로부터 특정 정보를 획득하기 위해 사용

- 또한, 호스트는 같은 네트워크 상의 라우터를 발견하고, 라우터는 노드가 메시지를 다른 곳으로 보내는 것을 도울 수 있음



# 오류 보고 메시지

> ICMP의 주 임무 중 하나는 `오류를 보고`하는 것이다.

오류 검사와 오류 제어가 IP의 관심사가 아니기 때문에, ICMP가 설계된 것

그러나, ICMP는 오류를 `수정`하는 것이 아니라 단지 `보고`만 수행

오류 수정은 상위 계층 프로토콜(TCP)에 맡겨짐

- ICMP 오류 보고 메시지의 생성
  - 라우터 OR 목적지 호스트에 의해 생성
- ICMP 오류 보고 메시지의 수신
  - 오직 발신지 호스트에 의해 수신됨
  - WHY? 데이터그램으로부터 알 수 있는 경로에 대한 정보는 발신지와 목적지 IP 주소뿐이기 때문
  
  > 어렵게 써놨지만 ICMP 오류 메시지 생성은 오류가 발생한 라우터나, 목적지 호스트가 생성하고,
ICMP 메시지 수신은 항상 원래의 발신지 호스트만 수신한다.

### ICMP 오류 메시지에 대한 중요 사항들

1. ICMP 오류 메시지를 전달하는 데이터그램에 대해서는 ICMP 오류 메시지가 생성되지 않는다.

- 패킷 전송 시 문제가 발생하면 ICMP 오류 메시지가 전달되는데, 이 전달되는 메시지에 문제가 생긴 경우에는 ICMP 오류 메시지가 생성되지 않는다.
- 그럼 어떻게 되나? -> 뒤에서 설명

2. 처음 단편이 아닌 단편화된 데이터그램에 대해서는 ICMP 오류 메시지가 생성되지 않는다.

- 첫 번째 단편에 대한 문제만 ICMP 오류 메시지가 생성

3. 멀티캐스트 주소를 가진 데이터그램에 대해서는 ICMP 오류 메시지가 생성되지 않는다.

4. 루프백 주소나 all-zero 주소 같이 특별 주소를 가진 데이터그램에 대해서는 ICMP 오류 메시지가 생성되지 않는다.


![](https://velog.velcdn.com/images/alstjr971/post/6d73a8ef-2070-4dcd-81e4-a31cb4bc9026/image.png)

- ICMP 프로토콜이 오류가 발생한 패킷을 수신
- 패킷 앞에 ICMP 헤더를 붙이고, 원 발신지 주소로 패킷을 다시 전송

### 다섯 가지 오류 유형

**다섯 가지의 오류 유형이 처리된다.**

![](https://velog.velcdn.com/images/alstjr971/post/973c041d-ef9c-481e-879c-141174fe3d1d/image.png)

**✅1. 도착지 도착 불가 메시지**

![](https://velog.velcdn.com/images/alstjr971/post/26a552a4-a3e3-4370-aff2-422d10cadf38/image.png)

- 라우터가 데이터그램을 전달할 수 없을 때,
- 호스트가 데이터그램을 배달할 수 없을 때

> 데이터그램은 폐기되고 라우터나 호스트는 데이터그램을 처음 보낸 발신지 호스트에게 '목적지 도달 불가 메시지'를 전송한다.

`Code 0` : 하드웨어 고장 등의 이유로 네트워크 도달 불가
`Code 1` : 호스트에 도달할 수 없음 -> 하드웨어 고장
`Code 2` : 프로토콜에 도달할 수 없음 -> TCP에 전달되어야 하는데 수신지 호스트에 TCP 프로토콜이 동작하고 있지 않는 경우
`Code 3` : 포트에 도달할 수 없음 -> 데이터그램이 향하고 있는 응용 프로그램이 실행 중이지 않은 경우
`Code 4` : 단편화가 필요하지만, 데이터그램의 DF 필드가 1로 지정되어 있음
`Others`

> Code2와 Code3 은 목적지 호스트에 의해서만 생성될 수 있고,
나머지 목적지 도달 불가 메시지는 라우터에 의해서만 생성될 수 있다.


**💡라우터가 목적지 도달 불가 메시지를 보고하지 않았다고 해서, 데이터그램이 정상적으로 배달되었음을 의미하지 않는다.🔥**

e.g, 데이터그램이 이더넷 네트워크를 지나가고 있다면, 이더넷은 확인 응답 메커니즘을 제공하지 않으므로 데이터그램이 목적지 호스트나 다음 라우터에 배달되었다는 것을 라우터는 알 수 없음

`목적지 도달 불가 메시지 정리`

- 목적지 도달 불가 메시지는 데이터그램이 어떠한 이유로 목적지에 도달할 수 없을 때 생성되는 메시지다.

**✅2. 발신지 억제 메시지**

IP 프로토콜은 `비연결형 프로토콜`이라고 했다.

IP 프로토콜은 `흐름 제어`와 `혼잡 제어`를 제공하지 않는다.

> 혼잡으로 인해 데이터그램을 폐기하면, 라우터나 호스트는 데이터그램의 송신자에게 발신지 억제 메시지를 전송한다.

이는 두 가지 목적으로 사용된다.

1. 데이터그램이 폐기되었음을 발신지에게 알림
2. 경로 상에서 혼잡이 일어났고, 발신지는 송신 과정을 천천히 해야 한다고 경고

![](https://velog.velcdn.com/images/alstjr971/post/b5969108-e078-4a3d-af3e-700d8f191096/image.png)

`발신지 억제 미시지 정리`

- IP 프로토콜에는 흐름 제어와 혼잡 제어 메커니즘이 없다.

- 발신지 억제 메시지는 라우터나 목적지 호스트에서 혼잡으로 인해 데이터그램이 폐기되었음을 발신지에 알린다.

**✅3. 시간 경과 메시지**

**시간 경과 메시지는 다음 두 가지 경우에 생성된다.**

1. TTL 필드 값이 1 감소 후, 0이 되면 라우터는 데이터그램을 폐기하고 시간 경과 메시지를 전송 -> `Code 0`

2. 만약 타이머가 만료되었음에도 불구하고, 아직 모든 단편이 도착하지 않았다면 목적지는 모든 단편들을 폐기하고 시간 경과 메시지를 전송 -> `Code 1`

![](https://velog.velcdn.com/images/alstjr971/post/35dd3b53-cc83-4d74-a2b8-6d6174e20859/image.png)

`시간 경과 메시지 정리`

- 라우터가 데이터그램의 수명 필드를 감소시킨 후, 그 값이 0이 되면 데이터그램을 폐기하고 시간 경과 메시지를 원 발신지에 전송한다.

- 최종 목적지가 정해진 시간 내에 모든 단편을 받지 못하면 이미 수신된 단편들을 모두 폐기하고 원래의 발신지로 시간 경가ㅗ 메시지를 보낸다.

- 시간 경과 메시지에서 `Code 0`은 수명 필드의 값이 0이 되었음을 알리기 위해 오직 `라우터`에 의해서만 사용된다.

- `Code 1`은 모든 단편이 지정된 시간 내에 도착하지 않았음을 알리기 위해 오직 `목적지 호스트`에 의해서만 사용된다.

> 당연히 목적지 도달 전에 라우터가 TTL을 감소시켰을 때 0이 되면 문제가 발생하는 거고, 단편 재조립은 목적지 호스트에서만 발생하기 때문.

**✅4. 매개변수 문제 메시지**

만약 라우터나 목적지 호스트가,

데이터그램의 필드에서 불명확하거나 빠진 값을 발견하게 되면,
데이터그램을 폐기하고 매개변수 문제 메시지를 전송한다.

**두 가지 경우**

1. `Code 0` : 헤더 필드 중에 불명료하거나 오류가 있는 필드가 존재하는 경우
2. `Code 1` : 옵션 중에서 요구되는 부분이 빠진 경우

![](https://velog.velcdn.com/images/alstjr971/post/299dd6f9-7b31-4739-884e-d34aba5eacd6/image.png)

**✅5. 재지정 메시지**

라우터들은 라우팅 갱신 프로세스에 참여해야 한다.

그러나, 효율성을 이유로 호스트들은 라우팅 갱신 프로세스에 참여하지 않는다.
- 호스트의 라우팅 테이블을 동적으로 갱신하면 네트워크 트래픽이 지나치게 많아지게 되기 때문

그 결과, 다른 네트워크에 도달해야 하는 데이터그램을 전송할 때, 호스트는 잘못된 라우터에게 그 데이터그램을 전송할 수 있다.

> 이 경우 데이터그램을 수신한 라우터는 데이터그램을 올바른 라우터에게 `포워딩`한 뒤, 호스트에게 `재지정 메시지`를 전송한다.

![](https://velog.velcdn.com/images/alstjr971/post/dafc5661-5f03-4b5a-96a6-b5332ea772ad/image.png)

![](https://velog.velcdn.com/images/alstjr971/post/e2d0e91f-0c1a-447a-8dd0-9ac5388a55c1/image.png)

---

# 질의 메시지

**4 가지 질의 메시지 쌍**

![](https://velog.velcdn.com/images/alstjr971/post/896bc891-fa0c-4401-9881-da86545505b7/image.png)

### 에코 요청과 응답

**이 메시지들은 고장진단의 목적으로 설계되었다.**

`에코 요청`과 `응답 메시지`들의 조합은 두 시스템이 서로 통신할 수 있는지를 결정 가능케 한다.

호스트나 라우터는 에코 요청 메시지를 호스트나 라우터에게 전송할 수 있다.
- 에코 요청 메시지를 수신한 호스트나 라우터는 에코 응답 메시지를 생성해 원래의 송신자에게 되돌려줌으로써, 두 호스트가 통신 가능하다는 것을 알린다.

> ICMP 메시지는 IP 데이터그램에 캡슐화되기 때문에, 에코 응답 메시지를 수신했다는 것은 다음을 증명한다.
1. 송신자와 수신자가 IP 데이터그램을 사용해 통신 가능
2. 중간에 있는 라우터들이 정상적으로 동작

![](https://velog.velcdn.com/images/alstjr971/post/e1010ca3-079d-46aa-9dd2-302825ecc465/image.png)


### 타임스탬프 요청과 응답

**이 메시지들은 IP 데이터그램이 두 개의 기계 사이를 지나가는 데 필요한 왕복 시간을 확인하는데 사용된다.**

![](https://velog.velcdn.com/images/alstjr971/post/37d4c93f-f359-4612-9cd5-fc67afb86ad6/image.png)

데이터에 보이는 3개의 타임스탬프 필드는 각각 32비트 길이를 가진다.

각 필드는 그리니치 표준시로 표현한 값이 저장된다.

> 타임스탬프 요청과 응답 메시지는 데이터그램이 발신지 -> 목적지 -> 발신지 까지의 왕복 시간 계산 용도로 사용된다.

`시간 계산 공식`
1. 송신 시간 : 수신 타임스탬프 - 원래 타임스탬프

2. 수신 시간 : 패킷이 돌아온 시간 - 전달 타임 스탬프

3. 왕복 시간 : 송신 시간 + 수신 시간

![](https://velog.velcdn.com/images/alstjr971/post/6215cd2b-e593-475f-a780-ea92944debfd/image.png)

> 이렇게 송신 시간과 수신 시간을 이용해 왕복 시간을 계산하는 것은 두 호스트 간 시계가 `동기화`되어 있어야 정확하다.

하지만 이러한 두 시스템 간 시간 동기화는 쉬운 일이 아니다.

🔥하지만! 두 시계가 동기화 되어 있지 않다 하더라도, `왕복 시간`의 계산은 항상 올바른 값을 보인다.

🤔왜 그럴까❓
각 시계의 값이 왕복 시간을 계산할 때 각각 두 번 적용되고, 그 결과로 동기화의 차이점이 서로 상쇄되기 때문이다.

말로 하면 어려우니 예시를 보자.

```
원래 타임스탬프 (original timestamp): 46, 수신 타임스탬프 (receive timestamp): 59,
전달 타임스탬프 (transmit timestamp): 60, 패킷이 돌아온 시간 (return time): 67
```
송신 시간 : 59 - 46 = 13
수신 시간 : 67 - 60 = 7
왕복 시간 : 20

송신 시간은 13mesc 인데, 수신 시간은 7msec다.
이 둘을 빼서 평균을 내면 13-7 / 2 = 3이 나오는데,
이 값이 바로 두 시계 간 차이를 나타낸다.


🤔 더 이해가 안되는데..

이렇게 생각해보자.

내 손목시계로 46초에 친구에게 메시지를 보냄

친구는 자기 손목시계로 59초라고 읽음

⇒ 내 시계와 친구 시계 사이에 +13초 차이가 있어 보임

친구는 자기 시계로 60초일 때 응답을 보냈고,

나는 내 시계로 67초에 그 응답을 받음

⇒ 응답이 오는 데 +7초 걸린 것처럼 보임

이제 문제는,

13초는 *"내가 보낸 시각과 친구가 받은 시각"*의 차이.

7초는 *"친구가 보낸 시각과 내가 받은 시각"*의 차이.

⏱️ 이 두 시간차의 비대칭성을 이용해 시계 차이를 찾는다!
전송 지연(S → D)과 수신 지연(D → S)이 완전히 대칭이라고 가정하면,
실제 네트워크 지연은 (13 + 7)/2 = 10초고,

그 가운데의 남은 차이, 즉 13 - 7 = 6초는 시계 차이에서 발생한 것이라고 볼 수 있다.

👉 그래서 이 차이의 절반인 6 / 2 = 3초가 **시계 차이(offset)**가 된다.

`타임스탬프 요청과 응답 정리`

- 시계가 동기화되어 있지 않더라도 타임스탬프 요청과 응답 메시지는 발신지와 목적지 사이의 `왕복 시간`을 측정하기 위해 사용될 수 있다.

- 정확한 `편도 시간`을 알 수 있따면, 타임스탬프 요청과 응답 메시지를 사용해 두 기계의 시계를 동기화시킬 수 있다.


---

# ICMP 패키지

> ICMP가 ICMP 메시지의 송신과 수신을 어떻게 처리하는지, 다음 두 가지 모듈로 구성된 ICMP 패키지를 보면 이해하기 쉽다.

- 입력 모듈과 출력 모듈로 구성

![](https://velog.velcdn.com/images/alstjr971/post/4fb54b75-f996-48a8-8d17-b34dcd032bbc/image.png)
