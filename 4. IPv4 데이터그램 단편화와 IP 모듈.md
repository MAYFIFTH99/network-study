# 0. 개요

인터넷 프로토콜(`IP`)은 

1. TCP/IP 프로토콜이 사용하는 전송 메커니즘이며,
2. 네트워크 계층에 위치한다.

> TCP/IP Protocol Suite 의 나머지 부분과 IP 관계
> 

![](https://velog.velcdn.com/images/alstjr971/post/11884e73-cd2f-46f1-9cab-41c3ba8be62d/image.png)


---

# 1. 데이터 그램

> IP = Internet Protocol
> 
- 신뢰성이 없고, 비 연결형인 데이터그램 프로토콜
    - 데이터그램: 네트워크 계층에서 사용하는 통신 단위로, 데이터 그램을 매번 최적의 길로 단순히 던진다.
- ‘최선의 노력 전달’ 서비스
- 즉, **패킷의 손상, 훼손, 분실, 순서, 지연, 혼잡** 등의 문제가 발생할 수 있다.

<aside>
💡

참고

IPv4와 IPv6는 많이 들어봤을 텐데, IPv5는 못 들어봤을 것이다.

그럼 IPv5가 없었나? 아니다. 개발 되었었는데, 인터넷 프로토콜을 ‘신뢰성’ 있는 프로토콜로 개발하다가 신뢰성을 제공하는 것이 오히려 역효과가 발생한다는 사실을 알고 폐기했다고 한다.

</aside>

## 1.1 데이터그램의 형식

### 1.1.2 IP 패킷 헤더

![](https://velog.velcdn.com/images/alstjr971/post/3553777c-2cf5-4098-b9d1-987065bc8b10/image.png)


차례대로 각각의 필드에 대해 알아보자.

1. VER(버전) - 4 bit
    1. 4 or 6 (0010 or 0110)을 표현(IPv4, IPv6)
    2. 만약 시스템이 해당 버전과 다른 버전을 사용하면 데이터그램은 폐기 됨
2. HLEN(헤더 길이) - 4 bit
    1. 데이터그램 `헤더`의 전체 길이를 4바이트 단위로 나타낸 것
    2. ex) HLEN = 20 바이트 → 20/4 = 5 로 표기
    3. 이때 헤더의 길이는 최소 20 바이트 ~ 최대 60 바이트까지 갖는 것을 유의
        1. 즉, HLEN 은  5 ~ 15의 범위를 가질 수 있음
3. Service Type(서비스 유형) - 8 bit
    1. 초기에 TOS(Type Of Service) 라고 불림
    2. 유료 서비스를 이용하는지 확인하는 용도였으나, 지금은 사용되지 않음
4. Total Length(전체 길이) - 16 bit
    1. 헤더와 데이터를 모두 포함한 IP 데이터그램의 길이를 `바이트 단위`로 나타낸 수
    2. 전체 길이와 헤더 길이를 이용해 데이터 길이를 구할 수 있음
        1. Total Length - Header Length
        2. ex) HLEN = 5, TLEN = 60, DLEN = ? → 60(byte) - 5*4(byte) = 40  byte
    3. **왜 전체 길이 필드가 필요한가?**
        1. 패킷은 가변 길이 데이터다. 따라서 패킷의 정확한 끝을 알기 위함
        2. 그리고 이더넷 프레임은 최소 64 바이트가 있어야 하고, 헤더와 트레일러를 제외한 데이터의 크기는 최소 46 바이트가 있어야 유실 없이 데이터가 전송된다고 한다.  따라서 만약 데이터 크기가 46 바이트 보다 작으면, 이더넷이 패딩을 해 이를 보완한다.
            
            <aside>
            💡
            
            따라서 패딩을 제외한 실제 데이터 범위가 어디까지인지 정보를 제공하기 위해 전체 길이 필드를 사용한다.
            
            </aside>
            
            <aside>
            💡
            
            어차피 MTU 보다 큰 데이터를 보낼 수 없는데 왜 굳이 전체 길이를 2^16 크기 만큼 설정했을까?
            
            - 수신자 입장에서는 결국 단편화된 모든 단편들을 모아 하나의 패킷으로 합쳐야 한다.
            - 따라서 그 전체 데이터 크기의 최대 값을 2^16 으로 설정한 것.
            </aside>
            
5. 식별
6. 플래그
7. 단편화 옵셋
- 2행에 있는 식별,플래그,단편화 옵셋 필드는 ‘단편화’ 장에서 설명
1. TTL(Time To Live) - 수명 (8 bit)
    1. 데이터그램은 목적지 호스트에 도달하지 못한 상태로 오랜 기간 두 개 이상의 라우터 사이를 떠돌아 다닐 수 있다. → 무한 루프
    2. TTL 필드는 이 떠돌이 데이터그램을 폐기할 때 사용
    3. 원래는 ‘타임스탬프’ 기능 (시간 오차) 수행을 위해 설계 되었지만, 오늘날에는 방문하는 ‘홉(라우터) 의 최대 수’를 제어하는데 사용됨
        1. 데이터그램을 처리하는 라우터는 이 필드의 값을 1씩 감소시키고, 0이 되면 폐기함
        2. 이를 응용해 TTL 값을 1로 설정하고 제한된 브로드 캐스팅 기능으로 사용  → 오.. 이거 재밌다
2. 프로토콜
    1. IP 계층의 서비스를 사용하는 상위 계층의 프로토콜을 정의하는 필드
        1. TCP, UDP, ICMP, IGMP 등 네트워크 계층 상위 계층인 전송 계층에서 사용하는 프로토콜을 명시함을 의미
    2. IP 패킷(데이터그램)이 최종적으로 전달되어야 하는 목적지 프로토콜을 명시
    
    > 왜 IP 패킷 헤더에 상위 계층에서 사용되는 프로토콜을 명시하는 필드가 있는걸까?
    - IP 계층은 데이터 전달 뿐만 아니라 해당 데이터를 ‘누구한테 넘겨줘야 할지’도 알아야 하기 때문
    - IP가 4계층 역할을 처리할 수 없도록 분리된 것은 맞다.
    - 그렇다고 막연히 데이터를 상위 계층에 던져줄 수도 없다.
      - 아무데나 던져서 TCP 포트에 던져버리면 패킷 해석 오류 발생 가능
    - 패킷을 받은 수신자 측의 OS와 라우터는 IP 패킷을 수신하면 protocol 필드를 보고 전달 대상을 지정한다.
    > 
3. checksum(검사 합) : 생략
4. Source IP : 발신지 IP 주소
5. Destination IP : 목적지 IP 주소

---

# 2. 단편화

데이터그램은 다른 네트워크를 지나갈 수 있다..

각 라우터는 수신한 프레임에서 IP 데이터그램을 역 캡슐화하여 처리하고, 다른 프레임 속에 캡슐화 한다.

- 라우터는 들어온 이더넷 프레임에서 이더넷 헤더와 트레일러를 제거하고 안에 있는 IP 데이터그램만 추출한다 → 역 캡슐화
- 그 후 출발지, 목적지 MAC 주소를 변경하여 새로운 이더넷 프레임에 싸서 다음 홉으로 보낸다.

이때 수신한 프레임의 형식과 크기는  프레임이 방금 지나온 네트워크가 사용하는 프로토콜에 의존한다.

- 라우터가 받은 프레임이 어떤 모양이고, 얼마나 큰지는 그 프레임이 오던 네트워크 종류에 따라 달라짐
- 이더넷으로 왔는지, 와이파이로 왔는지 등 크기 제한이 다 다르다.

송신할 프레임의 형식과 크기는 프레임이 바로 다음에 지나갈 네트워크가 사용하는 프로토콜에 의존한다.

- 보내는 경로가 사용하는 프로토콜에 맞춰서 프레임을 생성해 보내줘야 하기 때문.

## 2.1 최대 전달 단위 : MTU (Maximum Transfer Unit)

> 패킷을 몇 개로 조각낼 것인지 판단하는 근거
> 

각 데이터링크 계층 프로토콜은 자신의 프레임 형식을 가진다.

MTU는 프레임 내 데이터 필드의 최대 크기를 의미한다.

데이터그램이 프레임에 캡슐화 될 때, 데이터그램의 전체 크기는 이 최대 크기보다 작아야 한다. → 데이터그램의 크기는  MTU 보다 작아야 함을 다시 서술한 것.

![](https://velog.velcdn.com/images/alstjr971/post/c4595764-9e8e-443a-a500-cfadc1082956/image.png)


- 이더넷(무선 연결) 프로토콜의 최대 데이터그램 크기 는 1,500 바이트

데이터그램의 길이가 물리 네트워크의 MTU 보다 큰 경우, 전송을 위해 데이터그램을 분할(divde)해야 한다. → 계속 같은 말 중(데이터그램 크기 ≤ MTU)

<aside>
💡

이렇게 패킷의 데이터그램을 MTU 보다 작은 크기로 분할하는 것을 단편화(fragmentation)라고 한다.

</aside>

**🤔누가 단편화를 조립하는가❓**

👉 각 단편(fragment)이 독립된 데이터그램이므로, 데이터그램의 재조립은 ‘오직 목적지 호스트’에 의해서만 수행된다.

왜냐하면, 각 단편들은 동일한 네트워크 경로를 거쳐서 전달되지 않기 때문에, 중간 라우터가 해당 데이터그램을 재조립하려고 해도 다른 데이터그램들은 자신이 갖고 있지 않다.

## 2.2 단편화 필드

> **데이터그램이 단편화 될 때**, 헤더의 특정 부분은 모든 단편에 복사되어야 한다.
> 

- 데이터그램을 단편화하는 호스트나 라우터에 의하여 변경되어야 하는 3개의 필드가 존재한다.
    1. 플래그
    2. 단편화 옵셋
    3. 전체 길이

- 단편화와 관련은 있지만, 변경되지 않는 하나의 필드
    - 식별(Identification)

### 2.2.1 식별

**식별 필드는 발신지 호스트로부터 전송된 데이터그램을 유일하게 식별하는 기능을 한다**

- 식별과 발신지 IP 주소의 조합은(Identification + IP Address) 데이터그램이 발신지를 떠날 때, 유일하게 정의되어야 한다.
- 이러한 `유일성` 보장을 위해 IP 프로토콜은 `카운터`를 사용해 데이터그램에 `레이블`을 붙인다.
    - IP 프로토콜이 데이터그램을 보낼 때, 카운터의 현재 값을 식별 필드에 복사한 뒤, 카운터 값을 1 증가시킨다.
- 데이터그램이 단편화될 때, 식별 필드의 값은 `모든 단편에 복사` 된다.

> 이 식별 필드는 목적지에서 데이터그램을 재조립할 때 사용된다.
- 같은 식별 값을 가지는 모든 단편을 하나의 데이터그램으로 재조립하는 것
- 즉, 출발지에서 데이터그램을 단편화해서 보내게 되는데, 이 단편들은 각각 다른 라우터를 지나 도착할 수 있다.
- 따라서 목적지에서는 여러 경로를 통해 전달 받은 단편들을 하나로 조립하기 위해 기준(식별)이 필요한데, 이때 사용되는 것이 `식별` 필드인 것이다.
> 

### 2.2.3 플래그

**3비트의 필드**

![](https://velog.velcdn.com/images/alstjr971/post/07b012fe-dd36-46b1-aa25-557d4b79d185/image.png)


- 첫 번째 비트는 사용하지 않는다.
    - 추후 필요할 수 있어서 여유있게 3비트로 설계한 것

1. D(Do not fragment)
    1. 단편화 하지 마라. 라는 신호
    2. 만약 단편화의 크기가 MTU 보다 큰데, D 필드가 1이라면?
        1. 당연히 전송은 못한다. 따라서 폐기하고 ICMP 오류 메시지를 전송한다.
2. M(More fragments)
    1. 마지막 단편이 아니다.
        1. 뒤에 더 있다. 라는 신호

### 2.2.4 단편화 옵셋

**original datagram 내에서 데이터의 옵셋을 8 바이트 단위로 나타낸 것**

- 첫 번째 단편의 단편의 옵셋 = 0
- 두 번째 단편의 옵셋은?
    - if) 첫 번째 단편에 0~1399번까지의 바이트가 있으면,
    - 1400/8 = 175 가 두 번째 단편의 offset이다.

> 3계층의 패킷(데이터그램)도 MTU 보다 작게 단편화해서 보내고,
4계층의 세그먼트도 분할해서 보내고,
무슨 차이가 있는거지?
- 목적의 차이가 있다.
- 패킷 단편화는 MTU 초과 방지 목적(2계층 이더넷이 받을 수 있는 만큼)
- 세그먼트 분할은 흐름 제어, 전송 제어, 혼잡 제어를 위함(window)
> 

![](https://velog.velcdn.com/images/alstjr971/post/d30b439d-48a6-4188-a1e3-8c89598486ca/image.png)


![](https://velog.velcdn.com/images/alstjr971/post/721b417d-676d-4225-bd4a-0a202d0b678d/image.png)


- 식별자 필드에 14,567 이라는 값이 있다.
- 원 데이터그램의 offest 은 0 으로 되어 있다.
- Fragment 2는 다시 1400개를 800+600 으로 단편화 한 것
- 전체 길이에서 헤더 길이인 20을 빼고 계산

---

# 3. IP 패키지

![](https://velog.velcdn.com/images/alstjr971/post/6b637916-ba91-457b-ada7-e88aa4249523/image.png)


### 3.1 헤더 추가 모듈

**상위 계층 프로토콜로부터 데이터와 목적지 IP 주소를 수신**

그 후, IP 헤더를 추가함으로써 데이터를 IP 데이터그램 내에 `캡슐화`하는 모듈

### 3.2 처리 모듈

**IP 패키지의 핵심 모듈**

1. 처리 모듈은 인터페이스나 헤더 추가 모듈로부터 `데이터그램을 수신`
2. 데이터그램이 
    1. 최종 목적지에 도착 → 데이터그램을 `재조립 모듈`에 전송
    2. 노드나 라우터에 도착 → `TTL`을 1 감소
        1. TTL이 0 이하 → 데이터그램 폐기 후 ICMP 오류 메시지 전송
        2. TTL이 1 이상 → 데이터그램을 `포워딩 모듈`에 전송

### 3.3 라우팅 테이블

**IP 네트워크에서 목적지까지의 경로 정보를 저장**

- 다음 홉이나 출력 인터페이스를 결정하는데 사용
- IP 주소 기반 목적지 검색
- 다음 경로 결정

### 3.4 포워딩 모듈

**IP 데이터그램을 적절한 출력 인터페이스로 전달하는 실질적 실행 모듈**

1. 처리 모듈에서 TTL을 1 감소 시키고 전달 받음
2. 라우팅 테이블을 참조해
    1. 목적지 IP에 대한 최적 경로 검색
    2. 다음 홉 IP 주소 및 출력 인터페이스 결정
3. MTU 검사
    1. 데이터그램이 해당 인터페이스의 MTU보다 크면 `단편화 모듈`로 전달
4. ARP 요청 필요 시 ARP 패키지와 연동해 MAC 주소 확인
5. 최종적으로 L2 프레임 생성 후 전송

> 정리
경로 정보에 따라 데이터그램을 전송할 인터페이스를 결정한다.
- MTU 검사 후 단편화 판단
- L2 주소 확인 → 데이터 전달
> 

### 3.5 MTU 테이블

**단편화 모듈이 특정 인터페이스의 MTU를 찾기 위해 사용**

![](https://velog.velcdn.com/images/alstjr971/post/8029cb2e-25c1-410a-a7f4-af05fdf47285/image.png)


### 3.6 단편화 모듈

**포워딩 모듈로부터 다음을 수신**

1. IP 데이터그램
2. 다음 노드의 IP 주소
    1. 직접 전달 : 최종 목적지 IP 주소
    2. 간접 전달 : 다음 라우터 IP 주소
3. 데이터그램이 내보내져야 하는 인터페이스 번호

> 만약 데이터그램의 길이가 MTU 보다 더 크다면 단편화 모듈은 데이터그램을 단편화한다.
그 다음, 주소 해석(ARP)과 전달(Delivery)를 위해 ARP 패키지에 데이터그램을 전송
> 

### 3.7 재조립 테이블

**재조립 모듈에 의해 사용되는 테이블로, 미리 결정된 시간 내에 도착한 모든 단편들을 관리**

![](https://velog.velcdn.com/images/alstjr971/post/d702251e-d3c6-4193-b2d1-56d763d55087/image.png)


### 3.8 재조립 모듈

**처리 모듈로부터 최정 목적지에 도착한 데이터그램 단편들을 수신**

- 단편화되지 않은 데이터그램도 하나의 단편만을 가진 데이터그램의 단편으로 취급
- 단편들이 순서대로 도착한다는 보장이 없기 때문에, 재조립 테이블에서는 연결 리스트가 사용된다.
- 만약 정의된 타임아웃이 발생하였는데도 아직 도착하지 않은 단편이 있다면 재조립 모듈은 모든 단편들을 폐기한다.

---

> 대충 정리해보면,
> 
1. 처음 보내는 상황

즉, 상위 계층에서 캡슐화 된 세그먼트를 받는다.

여기에는 목적지 IP 주소와 payload가 들어있음

이제 여기에 출발지 IP 주소를 추가해 데이터그램을 생성한다.

여기까지가 헤더 추가 모듈이 할 일이고, 이제 처리 모듈로 보낸다.

데이터그램을 받은 처리 모듈은 현재 목적지로 도착했는지, 중간 과정인지 IP 주소를 보고 확인한다.

만약 목적지에 도착했다면, 재조립 모듈로 보낸다.

라우터에 도착했다면, TTL을 1 감소 시킨다

만약 TTL이 0보다 작아졌다면 데이터그램을 폐기하고 ICMP 오류 메시지를 보낸다.

TTL이 1 이상이라면 TTL을 1 감소시킨 후 포워딩 모듈로 보낸다.

포워딩 모듈에서 라우팅 테이블을 참조해서 목적지 IP 주소를 보고, 다음 홉 주소와 출력 인터페이스를 결정한다.

만약 이때 ARP 모듈이 필요하다면 연동해서 MAC 주소를 확인한다.

- 직접 전달인 경우(목적지 IP가 같은 서브넷인 경우)
    - MAC 주소가 ARP 캐시에 없다면 요청
- 간접 전달인 경우
    - 라우팅 테이블에 의해 다음 홉의 라우터 IP 주소가 결정
    - 해당 라우터의 MAC 주소 필요 → APR 캐시에 없다면 요청
    

이때 데이터그램 크기가 출력 인터페이스의 MTU 보다 크다면 단편화 모듈로 보내고, 아니라면 바로 데이터링크 계층으로 전송

1. 포워딩으로 받은 상황

출발지 IP 주소가 이미 들어있을테니까 바로 처리 모듈로 온다.

처리 모듈은 1번 상황의 시나리오를 똑같이 수행한다.
