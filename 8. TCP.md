# TCP 서비스

**TCP와 다른 프로토콜과의 관계**

![](https://velog.velcdn.com/images/alstjr971/post/4d9d5f87-601c-4abc-97d1-aca9ca38fad0/image.png)

> TCP 핵심 서비스
1. 프로세스 - 프로세스 통신
2. 스트림 배달 서비스
3. 연결 지향 서비스
4. 신뢰성 서비스
5. 전이중 통신
6. 다중화와 역다중화


## 1. 프로세스-대-프로세스 통신
- UDP와 같이, TCP는 포트 번호를 이용하여 프로세스-프로세스 통신을 제공한다.

## 2. 스트림 배달 서비스

- UDP와 달리, TCP는 `스트림-지향 프로토콜`임
- TCP에서 송신 프로세스는 바이트 스트림의 형태로 데이터를 전송하며, 수신  프로세스도 바이트 스트림의 형태로 데이터를 수신함
- TCP는 두 개의 프로세스가 `가상의 튜브`로 연결되어 있는 것과 같은 환경
  - TCP의 핵심 아이디어 : 가상화

> 🤔매번 `가상화`라는 단어가 혼란스럽다.
TCP에서 가상화는 '모든 네트워크 계층이 물리적인 세부사항을 숨기고, 상위 계층에 단순한 서비스 인터페이스를 제공'한다는 의미를 갖는다고 한다.

그럼 이게 `추상화`하고는 뭐가 다른 것인지 찾아보니, 다음과 같은 글을 보았다.

**추상화는 복잡한 것을 간단하게 숨긴다**

**가상화는 없는 걸 있는 것처럼 만든다**

즉, 추상화는 복잡한 객체를 단순화하여 나타내는 것이고, 가상화는 실제론 없지만 인터페이스나 부가 구현을 백그라운드에서 제공함으로써 마치 있는 것처럼 보이게 만드는 것이다.

![](https://velog.velcdn.com/images/alstjr971/post/14b41bdd-a7d5-4495-9359-883d2f67209f/image.png)

### 송신 버퍼와 수신 버퍼

- 송신 및 수신 프로세스가 동일한 속도로 데이터를 생성/소비하지 않을 수 있다.(대부분이 같은 속도 아닐 것임)

- 따라서 TCP는 생산 및 소비 프로세스의 속도 차이를 처리해야 한다.

- TCP에는 이러한 속도 차이를 해결하기 위해 `버퍼`를 사용한다

> 서로 다른 호스트 간 무슨 일을 하든, '속도 차이'가 발생한다면 반드시 '버퍼'를 사용하게 되어 있다.

이 버퍼를 구현하는 방법으로 배열, 연결 리스트, 큐, 원형 배열 등이 있다.

![](https://velog.velcdn.com/images/alstjr971/post/68feeaee-da2c-4884-84bf-0de3894f0879/image.png)

**세그먼트**

![](https://velog.velcdn.com/images/alstjr971/post/61a03ad4-33a0-4a3c-98d5-639b7ee3d71a/image.png)


TCP는 일련의 바이트를 세그먼트라고 하는 패킷으로 `그룹화`한다.

  - 세그먼트 = 헤더 + 데이터

세그먼트는 IP 데이터그램에 캡슐화되어 전송된다.
  - UDP와 동일

TCP는 
1. 순서에 어긋나게 수신
2. 손실
3. 손상
된 세그먼트를 재전송할 수 있다.

즉, IP 계층에서 발생하는 순서 오류, 손실, 손상을 상위 계층인 TCP가 제어하는 것이다.(ICMP로 해결할 수 없음)

> 세그먼트는 마지막에 자세히 설명한다.

---

## 3. 연결 지향 서비스

**TCP는 연결-지향 프로토콜이다.**

A 노드에 있는 프로세스가 B 노드에 있는 프로세스와 데이터를 주고 받고자 하는 경우, 다음 3가지 단계를 따른다.

1. 두 TCP 사이에 가상 연결 설정(전화를 건다)
   -  3 way handshake
2. 양방향으로 데이터 교환(통화를 한다)
3. 연결 종료(전화를 끊는다)

---

## 4. 신뢰성 서비스
**TCP는 데이터가 안전하고 오류 없이 잘 도착했는지를 확인하기 위해, 확인 응답 메커니즘을 이용한다.**

- 뒤에 오류 제어에서 설명

## 5. 전이중 통신
- 데이터는 동시에 양방향으로 전송 가능하다.
- 각 TCP는 송신 버퍼와 수신 버퍼를 갖고 있으며, 세그먼트는 양방향으로 전송된다.

## 6. 다중화와 역다중화

- 송신 측: 여러 애플리케이션의 데이터를 TCP가 포트 번호로 식별하고, 세그먼트로 생성하여 전송 → 다중화(OS가 QUEUE에 넣음)
- 수신 측: TCP가 수신한 세그먼트를 포트 번호로 확인하고, 해당 소켓의 프로세스로 전달 → 역다중화

---

# TCP 특징

## 1. 번호화 시스템

> 어떤 세그먼트가 전송, 수신 되었는지를 추적하기 위해 TCP는 `순서 번호`와 `확인 응다바 번호`라는 두 개의 필드를 가진다.

### 🔹1.1 바이트 번호

- TCP는 한 연결에서 전송되는 모든 데이터 바이트에 '번호를 매긴다'
- 번호는 0부터 시작할 필요는 없으며, 0부터 2^32-1 사이의 임의의 값을 선택한다
   - 보안, 식별을 위함

예를 들어 임의의 값으로 1057이 선택되고, 전송하고자 하는 총 데이터가 6000바이트라면, 1057부터 7056까지의 번호가 전송되는 바이트 각각에 번호가 매겨진다.

> 각 방향으로 전송되는 데이터 바이트는 TCP에 의해 번호가 매겨진다.
번호는 임의로 생성된 값에서 시작한다.


### 🔹1.2 순서 번호

- 바이트에 번호가 매겨지면, TCP는 전송하고자 하는 세그먼트에 하나의 순서 번호를 할당한다.
- 각 세그먼트의 순서 번호는 그 세그먼트에 있는 `첫 번째 바이트의 번호`로 설정된다

![](https://velog.velcdn.com/images/alstjr971/post/a84b5f31-ae3a-48ec-9c9c-5bec20661853/image.png)

### 🔹1.3 확인응답 번호

- TCP는 자신이 바이트를 수신하였다는 것을 알려주기 위해 `확인응답 번호`를 이용한다.
- **확인응답 번호는 자신이 다음으로 받아야 할 바이트 번호**를 정의
  - 또한, 확인응답 번호는 `누적`된다.

> 누적이라는 의미는, 한쪽 편에서 확인응답 번호로 5,643을 사용했다면, 처음부터 5,643까지의 모든 바이트를 수신했다는 것을 의미한다.
따라서 이전 확인응답 번호가 손실되었더라도, 이를 이용해 다음 세그먼트를 송신하면 되는 획기적인 아이디어다.

## 2. 흐름 제어

> 흐름 제어는 목적지로부터 `확인응답`을 수신하기 전에, 발신지가 전송할 수 있는 데이터의 양을 정의한다.

![](https://velog.velcdn.com/images/alstjr971/post/9e895c25-5a5c-495a-887d-cb01040f17d2/image.png)

TCP는 두 개의 극단 사이 값으로 데이터를 교환한다.

- 전송할 데이터 저장 -> 송신 버퍼 사용
- 전송할 데이터의 크기 결정 -> `윈도우` 정의

TCP는 `슬라이딩 윈도우 프로토콜`에서 정의된 양만큼의 데이터를 송신 버퍼로부터 읽어서 전송할 수 있다.

### 🔹2.1 슬라이딩 윈도우 프로토콜

흐름 제어를 위하여, TCP는 슬라이딩 윈도우 프로토콜을 이용한다.

호스트는 아웃바운드 통신(외부로 나가는)을 위해, 윈도우를 사용한다.

`윈도우`는 프로세스로부터 수신된 바이트들을 포함(송신 버퍼)하는 버퍼의 일부분에 걸쳐있다.

**송신 버퍼**
![](https://velog.velcdn.com/images/alstjr971/post/65e86379-77aa-4dfe-8979-9bb4bebf9205/image.png)

윈도우에 속한 바이트들은 전송 가능한 바이트들이다.
- 이 바이트들은 확인응답에 대한 걱정 없이 전송 가능

> 가상의 윈도우는 두 개의 벽을 가지는데, 왼쪽 벽과 오른쪽 벽이 `슬라이드`할 수 있기 때문에, 이 윈도우를 슬라이딩 윈도우라고 부르는 것


**수신 버퍼**

![](https://velog.velcdn.com/images/alstjr971/post/9c1a8a64-8c88-45a3-a22c-e0a370107f0f/image.png)

수신 응용프로세스가 소비할 다음 바이트는 194번 바이트다.
수신 TCP는 200번 바이트 수신을 기다린다.

수신 TCP의 수신 가능한 바이트 수는?
- 수신 버퍼의 전체 크기가 N이고, M개의 위치가 이미 점유되어 있으면, N-M-1 개의 바이트만 더 수신 가능(원형 배열)

**송신 윈도우**
![](https://velog.velcdn.com/images/alstjr971/post/aa7c7642-e51c-409e-ab93-eaed19ce49e2/image.png)

수신 윈도우보다 같거나 작은 크기로 송신 윈도우를 지정하면, `흐름 제어`가 가능하다.
송신 윈도우 = 확인 응답되지 않은 바이트 + 전송될 바이트

송신 윈도우가 7일 때, 3개의 바이트는 이미 전송하였고 추가로 4개의 바이트를 전송 가능하다.

> 송신 윈도우의 크기는 보수적으로 잡아야 한다.
왜냐하면, 200,201,202 이 아직 수신 버퍼에 도착하지 않았다면, 이들을 뺀 값을 송신 윈도우 크기로 잡아야 수신 버퍼에 오버플로우가 발생하지 않기 때문

수신 프로세스가 데이터를 빠른 속도로 처리하면 수신 윈도우의 크기가 확장된다. 이를 송신 프로세스 측에도 전달해야 하고, 이를 받으면 송신 윈도우의 크기가 증가하면서 효율적인 데이터 교환이 이뤄지는 것이다.(그 반대도 마찬가지)

그러다 수신 버퍼가 가득 차면 수신 윈도우의 크기가 0이되고, 이를 송신 측이 알게되면 송신 윈도우도 닫는다.

이후 송신 측은 수신 측에서 0이 아닌 윈도우 값을 알려줄 때까지 더 이상 데이터를 전송하지 않는다.(못한다)

`정리`

TCP에서, 송신 윈도우의 크기는 완전히 수신 윈도우 값에 의해 제어된다.

그러나, 네트워크에 혼잡이 발생할 경우, 실제 윈도우 크기는 더 작아질 수 있다.
- EX) 수신 측은 괜찮은데, 중간에 라우터들이 혼잡한 경우
- 혼잡 제어에서 다룬다

**TCP 슬라이딩 윈도우에 대한 특징**
1. 발신지는 전체 윈도우만큼의 데이터를 전송할 필요가 없다.
2. 윈도우의 크기는 목적지에 의하여 증가 또는 감소될 수 있다.
3. 목적지는 확인응답을 언제는지 보낼 수 있다.

---

## 3. 오류 제어

**TCP를 통해 데이터 스트림을 전달하려는 응용 프로그램은 다음을 TCP에 의존한다**

전체 스트림을 
1. 순서대로
2. 오류 없이
3. 손실 없이
4. 중복 없이
상대 응용 프로그램에 전달한다.

- TCP는 `오류 제어`를 사용해 `신뢰성`을 제공한다.

> 오류 제어는 손상된 세그먼트, 손실된 세그먼트, 순서가 맞지 않는 세그먼트, 복제된 세그먼트를 검출하기 위한 메커니즘들을 포함한다.
- 오류 검출 뒤에는 오류를 정정하는 메커니즘도 포함함.

### 🔹3.1 오류 발견

1. 검사합
   - 손상된 세그먼트를 검사 -> 손상된 세그먼트 폐기
2. 확인응답
   - 손상되지 않은 세그먼트 수신을 통보
   - 부정 확인은 사용하지 않음
3. 시간 초과
   - 송신 TCP는 각 세그먼트마다 하나의 시간 초과 counter를 지정
  
### 🔹3.2 오류 정정

1. 발신지 TCP는 전송한 세그먼트 각각에 대하여 하나의 시간초과 카운터 구동
2. 시간초과 카운터가 설정된 값이 되면, 재전송

### 🔹3.3 손상 세그먼트

![](https://velog.velcdn.com/images/alstjr971/post/1fe9b691-e70e-42dc-b418-98c447c251ad/image.png)

- 손상된 패킷을 확인하고 이를 폐기한다.
- 이때 NACK (부정 확인응답)은 보내지 않으므로, 타임아웃이 발생
- 타임아웃이 발생하면 송신자 측은 세그먼트를 재전송한다.


### 🔹3.4 손실 세그먼트

![](https://velog.velcdn.com/images/alstjr971/post/248d33f4-e073-4ac2-b706-483dca406557/image.png)

> 손상, 손실은 결국 같은 결과를 가짐

### 🔹3.5 중복 세그먼트

- 타임아웃이 발생하기 전에, 동일한 세그먼트가 도착하면 수신 측은 나중에 도착한 것을 폐기한다.

### 🔹3.6 순서에 어긋난 세그먼트

TCP 세그먼트는 IP 데이터그램에 캡슐화된다고 했다.
각 데이터그램은 독립적인 개체이기 때문에 어떤 데이터그램은 짧은 지연을 가지는 경로로 보내질 수 있고, 다른 데이터그램은 긴 지연을 갖는 경로로 보내질 수도 있다.

> TCP는 순서에 맞게 모든 세그먼트를 수신할 때까지, 순서가 맞지 않는 세그먼트에 대하여 확인응답을 보내지 않는다

그럼 이때 순서에 맞지 않게 받은 세그먼트를 폐기할까? 따로 보관할까?
- 옛날에 메모리가 귀하던 시절에는 세그먼트를 폐기했다.
- 최근에는 1,3이 오고 2가 올때까지 3을 보관해놨다가, 2가 오면 확인응답으로 3을 보낸다.

### 🔹3.7 확인응답의 손실
![](https://velog.velcdn.com/images/alstjr971/post/1d46963b-aced-492a-a2c5-bec1a232f191/image.png)

- 확인응답이 손실되어도 확인응답 값은 `누적`되기 때문에, 이후 세그먼트에 대한 응답 값만 제대로 보내진다면 송신 측은 정상적으로 동작한다.(아무 오류 보고 없이)

---

## 4. 혼잡 제어

> 혼잡 제어는 라우터가 패킷을 처리할 수 있는 속도보다 더 빨리 패킷을 수신하는 경우에 발생한다.

혼잡이 발생하면, 라우터에서 패킷이 `손실`된다.

손실된 패킷은 목적지에 도착하지 못하므로 당연히 확인 응답도 전송되지 않는다.

송신 TCP는 타임아웃이 발생해 세그먼트를 재전송한다.

그럼 안그래도 혼잡한 라우터는 더욱 더 많은 세그먼트를 수신하면서 혼잡 현상이 더 극심해질 수 있다.

> 따라서, TCP는 이러한 상황을 피할 수 있는 방법을 찾아야 했고, 이를 혼잡 제어를 통해 해결한다.


앞에서 수신 TCP에 의한 흐름 제어를 설명했다.
- 송신 윈도우 크기는 수신자의 사용 가능한 버퍼 공간에 의해 결정
- 흐름 제어에서는 송신 윈도우 크기는 수신 TCP에 의해서만 조절

> 💡혼잡 제어를 위해서는 '네트워크가 수신 측과 더불어 송신 측의 윈도우 크기를 결정할 수 있는 또 다른  개체'(라우터)가 되어야 한다.

**실제 윈도우 크기 = MIN(수신 TCP가 보내준 윈도우 크기, 혼잡 윈도우 크기)**

### 혼잡 정책

1. 느린 시작과 가산 증가 : +로 증가시키고 x 로 감소시킴
2. 지수 감소

### 🔹느린 시작 : 지수 증가

연결 초기에, TCP는 `혼잡 윈도우`의 크기를 하나의 최대 세그먼트 크기인 `MSS` 로 설정한다.(MTU - 20 - 20)

TCP는 확인응답을 받는 각 세그먼트에 대해, 혼잡 윈도우의 크기를 `임계치`에 도달할 때까지, 하나의 최대 세그먼트 크기만큼 증가시킨다.(1 -> 2 -> 4 -> 8 .. -> MSS)
- 초기 임계값은 사용 가능한 창 크기의 절반임

![](https://velog.velcdn.com/images/alstjr971/post/1e0f84f5-94a6-422c-8f4c-165937f7ca8f/image.png)


### 🔹가산 증가 : 혼잡 회피

그러다 혼잡 윈도우의 크기가 임계치에 도달하면, 느린 시작이 중지되고, 다음 단계인 `가산 증가`가 시작된다.

- 이는 지수 증가로 인한 혼잡 윈도우의 크기 때문에 발생 가능한 혼잡을 회피하기 위함임

이 알고리즘에서, 증가는 도착한 ACK 개수에 기반하지 않고, RTT(Rount-Trip Time 왕복 시간)에 기반한다.
- 그 결과, 송신자가 완전한 윈도우 크기의 세그먼트들에 대한 모든 ACK들을 수신한 후에, 윈도우의 크기는 하나의 세그먼트 만큼 증가한다.

![](https://velog.velcdn.com/images/alstjr971/post/bafdc6c4-8dff-4e00-aaab-45bd1c348bda/image.png)

RTT 동안 4개를 보냈을 때 확인응답으로 4개를 모두 받으면 윈도우 크기를 1 증가


### 🔹지수 감소 : 혼잡 감지

혼잡이 발생하면, 혼잡 윈도우의 크기를 감소해야 한다.

송신자가 혼잡이 발생했다고 추측할 수 있는 유일한 방법은 '새그먼트의 재전송 필요성'이다.

대부분의 TCP 구현에는 다음과 같은 두 가지 리액션이 존재한다.

1. 🔸타임아웃
   - TCP는 임계치를 현재 윈도우 크기의 절반으로 조정한다.
   - `cwnd`를 다시 하나의 세그먼트 크기로 줄이고, 느린 시작 단계를 시작
   - cwnd: congestion window
2. 🔸3개의 중복 ACK이 수신되는 경우 : 손실이 여러 번 발생
   - TCP는 임계치를 현재 윈도우 크기의 절반으로 조정한다.
   - `cwnd`를 임계치 값으로 설정하고, 혼잡 회피 단계를 시작한다.

![](https://velog.velcdn.com/images/alstjr971/post/23cdba51-9c87-4032-bada-61a40afae6c6/image.png)


> 왜 타임아웃에는 윈도우를 초기화하는데, 중복 3번 발생할 때는 절반으로 줄일까?

왜냐하면 타임아웃이 중복보다 훨씬 심각한 문제이기 때문이다.
중복이 됐다는건 어쨋든 이전 세그먼트는 정상적으로 도착했다는 것을 의미하는데, 시간 초과는 모든 세그먼트가 도착하지 않았음을 의미하기 때문

---

# 세그먼트

![](https://velog.velcdn.com/images/alstjr971/post/41f039d3-752e-4b73-b95c-0da250add444/image.png)

### 제어

- 6개의 제어 비트 또는 플래그로 구성
- 동시에 여러 개의 비트가 1로 지정 가능

![](https://velog.velcdn.com/images/alstjr971/post/d2718c8b-12a9-427d-8925-d81dc24d72d6/image.png)

### 세그먼트 헤더 필드

1. 윈도우 크기
   - 송신 TCP의 윈도우 크기를 바이트 단위로 정의한 것
   - 이 값은 수신 윈도우로 지칭되며, 수신자에 의해 결정됨
2. 검사합
3. 긴급 포인터
   - `제어`에서 긴급 플래그가 1로 세팅된 경우 긴급 데이터의 위치를 나타냄
4. 옵션

나머지 발신지 포트 주소, 순서 번호, 확인응답 번호 등은 생략하겠다.

# TCP 연결

연결-지향 전송 프로토콜은 발신지와 목적지  간의 `가상 경로`를 설정한다.

하나의 메시지에 속하는 모든 세그먼트들은 이러한 가상 경로를 통해 전송된다.

> TCP도 결국 비연결형 프로토콜인 IP 서비스를 이용해야 하는데, 어떻게 연결-지향 프로토콜이 될 수 있는 것일까?

TCP 연결은 '물리적인 것이 아닌 가상' 연결이다.
- TCP는 IP 프로토콜 상위 단계에서 동작
- TCP는 수신자에게 각각의 세그먼트를 전달하기 위해 IP의 서비스를 이용하지만, 연결은 TCP가 제어한다.
- 손실되거나 훼손된 세그먼트는 TCP에 의해 재전송됨

IP는 이러한 재전송 과정을 인지하지 못한다. 그저 목적지로 보낼 뿐.

## 연결 설정

### 전이중 모드

TCP는 전이중 모드로 데이터를 전송한다.
두 기계에 존재하는 두 개의 TCP가 서로 연결되면, 동시에 서로 세그먼트를 전송할 수 있게 된다.

이것은 데이터의 교환이 이루어지기 전에, 하나 당사자가 `통신을 개시`하고, 다른 당사자로부터 `통신 개시 요구에 대한 승인`을 받아야 함을 의미한다.

### 3-way handshake
![](https://velog.velcdn.com/images/alstjr971/post/1016f5f4-728a-4937-8cee-d07f48c8171b/image.png)

- SYN 세그먼트는 데이터를 전달하지는 않지만, 하나의 순서 번호를 `소비`한다.

- SYN + ACK 세그먼트는 데이터를 전달하지는 않지만, 하나의 순서 번호를 소비한다.

- ACK 세그먼트는 데이터를 전달하지 않는 경우에는 순서 번호를 소비하지 않는다.

> 🔥🔥 중요🔥🔥
데이터가 없는 ACK은 새로운 시퀀스 넘버를 소비하면 안 된다!!🔥

이때는 사용 가능한 제일 마지막 바이트 번호를 사용해야 한다
### 데이터 전송

![](https://velog.velcdn.com/images/alstjr971/post/326f403e-83cc-4fc0-9eef-709b94f966c7/image.png)

### 연결 종료
![](https://velog.velcdn.com/images/alstjr971/post/d2c953e1-430f-4af2-8cc7-66671aea8eca/image.png)

- 데이터를 포함하지 않는 FIN 세그먼트도 하나의 순서 번호를 소비한다.
- 데이터를 포함하지 않는 FIN+ACK 세그먼트도 하나의 순서 번호를 소비한다.

> 즉, 데이터가 없는 ACK 만 순서 번호를 소비하지 않는다.

![](https://velog.velcdn.com/images/alstjr971/post/e2b063d8-dffe-46cc-b92d-7e510f5da208/image.png)

왜 이렇게 설계했을까?
- 클라이언트가 서버에게 파일 다운로드를 요청한 후, 클라이언트->서버 방향으로의 연결을 종료하고, 서버는 일을 다 마치고 연결을 끊음으로써 자원을 효율적으로 사용하기 위함

### 연결 리셋

1. 연결 거절 (Denying a Connection)
   - 한 쪽의 TCP가 존재하지 않은 포트 (nonexistent port)로 연결을 요청하는 경우에,
      - 다른 쪽의 TCP는 요청을 거절하기 위하여, RST 비트를 설정한 세그먼트를 전송함
   
2. 연결 중단 (Aborting a Connection)
   - 한 쪽의 TCP가, 비정상적인 상황 (abnormal situation)으로 인하여, 이미 존재하는 연결을 중단(abort)하고자 하는 경우,
     - RST 세그먼트를 전송함
   
3. 휴지 연결의 종료 (Terminating an Idle Connection)
   - 한 쪽의 TCP는 다른 쪽의 TCP가 오랜 시간동안 휴지 상태 (idle for a long time)에 있다는 것을 확인한 후, 연결을 파기하고자 하는 경우,
     - RST 세그먼트를 전송함
     
---

**TCP는 다음 그림과 같은 `유한 상태 기기`를 이용하여 구현된다**
![](https://velog.velcdn.com/images/alstjr971/post/554aed27-f49f-4f33-9b1d-934b95099132/image.png)
