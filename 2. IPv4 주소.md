# 1. 개요

Internet에 연결되어 있는 각 장치를 `식별`하기 위해 TCP/IP 프로토콜 모음의 IP 계층(3 계층)에서 사용하는 `식별자`를 인터넷 주소 또는 `IP 주소`라고 한다.

- 그 만큼 IP 주소가 중요하다는 의미

---

# 2. 클래스 기반 주소지정(Classul Addressing)

수십 년 전의 시작 시점에 IP 주소는 `Class` 개념을 사용했다.

이러한 구조를 클래스 기반 주소지정이라고 한다.

클래스 기반 주소지정 방식에는 낭비되는 IP 주소가 많은 문제가 있어 이후 클래스없는 주소지정 방식이 소개되었다.

## 클래스

1. Class A : 2의 31승 개의 주소를 갖는 클래스
2. Class B : 2의 30승 개의 주소를 갖는 클래스
3. Class C : 2의 29승 개의 주소를 갖는 클래스
4. Class D : 2의 28승 개의 주소를 갖는 클래스
5. Class E  : 2의 28승 개의 주소를 갖는 클래스

>💡왜 2로 나누었을까?

1. Bit Operation
    1. 컴퓨터는 이진수를 사용하기 때문에 컴퓨터 시스템에서 주소를 다룰 때 효율적
2. 효율적인 주소 할당
    1. 배수 관계가 명확해 주소 할당이 쉽고 해당 주소가 어느 클래스에 속하는지 직관적으로 파악 가능
3. 네트워크 마스크 계산 편리
    1. 네트워크 마스크의 계산도 2의 거듭 제곱을 기준으로 이루어지기 때문에, 주소 공간을 나누는 데 있어 일관되게 계산 가능

### 라우팅 프로세스

1. 목적지 주소를 네트워크 마스킹과 AND 연산하여 네트워크 주소를 얻는다.
2. 라우팅 테이블에서 위에서 얻은 네트워크 주소에 대응되는 인터페이스(라우터)를 찾아 전달한다.

---

# 3. 클래스 없는 주소지정(Classless Addressing)

클래스기반 주소지정 방식에서  서브네팅과 수퍼네팅은 `주소 고갈 문제`를 해결하지 못하고 있다.

인터넷이 성장함에 따라, 좀 더 긴 주소 공간을 확보하는 것이 장기적인 해결책이 될 것이다.

비록  IPv6 라고 하는 장기적인 해결책이 이미 고안되었지만, 동일한 주소 공간을 사용하면서도 기관들에게 균등하게 주소를 배분할 수 있도록 하기 위한 단기적인 해결책 또한 제시되었다.

→ 단기적 해결책 : IPv4 주소를 그대로 사용하며, 클래스 없는 주소지정 방식이라 불림

## 가변 길이 블록

클래스 없는 주소지정 방식에서, `프리픽스`(prefix)는 네트워크를 정의하고, `서픽스`(suffix)는 호스트를 정의한다.

![](https://velog.velcdn.com/images/alstjr971/post/8aebeb2d-6632-4858-b378-608d13742153/image.png)


- prefix의 길이는 0~32 의 범위를 가질 수 있다. → suffix는 32-prefix

---

# 4. 특별 주소

- 클래스 기반 주소지정 방식에서 일부 주소는 `특수 목적`을 위하여 예약 되었다.
- 클래스 없는 주소지정 방식에서도, 이를 그대로 차용해 동일한 목적의 `특수 주소`들이 정의되어 있다.

## 특수 블록과  블록에 속하는 특수 주소

### 1. all-zero 주소 - 0.0.0.0 (특수 블록)

![](https://velog.velcdn.com/images/alstjr971/post/d0e84007-0a3e-450c-82c5-711af8e7a8ff/image.png)


- 자기 자신의 주소를 모르는 장치가 패킷을 보낼 때, 우선 0.0.0.0 으로 설정하고 전송한다.
- 자기 자신의 주소를 알기 위해 DHCP 서버에 요청을 보낼 때도 사용

### 2. Limited Broadcast Address - 255.255.255.255

![](https://velog.velcdn.com/images/alstjr971/post/603e4086-4a12-4dc7-8190-bac3ef3f706d/image.png)


- 자신이 속한 네트워크에 포함된 모든 장치들에게 전송
- 다른 네트워크를 거치지 않고 걸러지기 때문에 `제한`된 브로드캐스팅이라고 함
    - 라우터가 다른 broadcast는 차단

### 3. Directed Broadcast Address - x.y.z.255 .. etc

![](https://velog.velcdn.com/images/alstjr971/post/7c6d4b66-5d71-4970-bd6e-196c2c96dd12/image.png)


- 특정 네트워크에 속하는 모든 장치에게 전송

### 4. Loopback Address - 127.x.y.z

![](https://velog.velcdn.com/images/alstjr971/post/0299a448-688d-4183-adaf-22cbb4de771f/image.png)


- 현재는 127.0.0.1 만 사용됨
- 초기 설계 당시에는 해당 네트워크가 많이 사용될 줄 알고 2^24 개의 호스트를 사용할 수 있게 했지만, 막상 그렇지 않다보니 낭비되는 중 → 초기 설계의 중요성

### 사설 IP 네트워크 대역 ( 특수 블록)

![](https://velog.velcdn.com/images/alstjr971/post/66706ece-6584-4120-9e21-446494786d83/image.png)


1. 10.0.0.0/8
2. 192.168.0.0/16
3. 172.16.0.0/12
4. 169.254.0.0/16 (Link - Local Address)
    - 무인도 같이 네트워크가 안되는 환경에서는 DHCP 에게 IP 할당 요청을 보낼 수 없다.
    - 즉, DHCP 서버에서 IP를 못 받았을 때 윈도우 같은 운영체제에서 자동으로 이 대역의 주소를 임의로 할당한다.
    - 인터넷 연결이 안되는데 왜 굳이 운영체제에서 할당하나?
        - 최소한 로컬 네트워크 내 장치들끼리는 통신할 수 있게 해주기 위함

---

# 5. NAT

ISP를 통하여 주소를 배분하는 것은 새로운  문제를 야기한다.

사업이 번영하거나, 가정 집에서 좀 더 큰 범위의 IP 주소를 필요로 하는 경우, ISP가 주소들을 다른 네트워크에 이미 할당하였다면 이 요청을 받아들일 수 없다.

ex) 192.168.0.0/12 ~ 192.168.15.255/12 의 블록을 할당 받았다고 가정해보자.

근데 호스트 수가 늘어나 더 큰 IP 주소가 필요해져서 192.168.16.0 의 네트워크 주소를 갖는 네트워크 대역을 할당 요청했지만, 해당  대역은 이미 다른 사람에게 할당되어서 받아들여지지 않는 경우

>💡연속되지 않은 주소는 할당할 수 없다. 
🤔왜? 👉 네트워크 마스크와 AND 연산했을 때 네트워크 주소가 동일해야 하니까.

하지만, 대부분의 경우 하나의 네트워크에 속하는 컴퓨터들의 일부분만 동시에 인터넷 접속을 필요로 한다.

이러한 경우 적용 가능한 기술이 바로 NAT(네트워크 주소 변환) 기술이다.

### 1차 NAT - Private 주소 중복 사용

![](https://velog.velcdn.com/images/alstjr971/post/f9e00229-1360-4541-b118-415af37acf9d/image.png)


- 테이블을 이용하여 해결하려 했지만 실패했다.
- 172.18.3.X 네트워크에 포함된 다른 호스트, 예를 들어 172.18.3.2 도 동시에 요청을 보냈다고 가정해보자.
- 그러면 Translation 에 172.18.3.2 - 25.8.2.10 으로 작성될 것이다.
- 데이터를  받은 25.8.2.10은 해당 데이터를 누가 보냈는지 확인하기 위해 테이블을 확인할 것이다.
- 이때 3.1이 보냈는지, 3.2 가 보냈는지 구분할 수가 없는 문제가 발생

### 2차 NAT - Port 번호 이용

![](https://velog.velcdn.com/images/alstjr971/post/968337cb-9909-4c16-a5b1-5fc5a4ed1f78/image.png)


- 또한 문제점 발생
- 포트 주소는 2 바이트 크기를 갖는다. 즉 65536 개를 랜덤하게 써도 동일할 확률이 존재함

>💡즉, 어떤 호스트가 보냈는지 구분하기 위해 포트 번호라는 정보를 추가해서 사용해 해결하려 했는데, 포트 번호도 중복될 가능성이 존재한다


NAT 를 사용해서 IP 주소 부족 문제를 해결하려 했고, 

이때 translation table 을 이용해 구현하려 했는데 동일한 네트워크 주소를 갖는 호스트가  같은 공인 IP 로 변환되는 경우, 

데이터를 받은 수신자 측에서 해당 데이터를 어떤 호스트가 보냈는지 식별할 수 없는 문제점이 발생했고,

 이를 해결하기 위해 포트 번호라는 추가 정보까지 명시했지만,

이것 또한 충돌할 수 있는 문제가 있어 `PAT`라는 NAT와 유사한 변환 장치를 하나 더 사용해서 해결한다.
