TCP/IP 프로토콜을 사용하는 각 컴퓨터(호스트)들은 자신의 `IP 주소`를 알고 있어야 한다.

만약 컴퓨터가 Classless 주소 체계를 사용하거나, 서브넷의 멤버라면 서브넷 마스크를 알아야 한다.

두 개에 더불어, 오늘날의 대부분의 컴퓨터는 다음의 두 가지 정보를 추가로 필요로 한다.

1. Default Louter 주소
- 다른 망과 통신하기 위함

2. 네임 서버 주소
- 주소 대신에 이름을 이용해 통신하기 위함

> 정리하면, 컴퓨터가 통신하기 위해서는 반드시 4가지의 정보를 알고 있어야 한다.

1. 자신의 IP 주소
2. 서브넷 마스크 주소 -> 대상 IP 주소가 같은 네트워크에 속해 있는지 판단
3. Default 라우터 주소
4. 네임 서버 주소

이렇게 4가지 정보를 얻기 위해 옛날에는 두 개의 프로토콜을 사용했다.

### ✅RARP(Reverse Address Resolution Protocol)
- ARP의 역방향
- MAC -> IP 

### ✅BOOTP(Bootstrap Protocol)

- RARP는 물리 주소를 IP 주소로 매핑하낟.
- 🚨그러나 RARP는 다음 두 가지 이유로 거의 사용되지 않는다.
   1. 데이터링크 계층의 브로드캐스트 서비스를 사용해야 하는데, 이는 RARP 서버가 각 네트워크에 존재해야 함을 의미 -> 서브넷이 N개면 N개의 RARP가 필요
   2. 컴퓨터는 앞서 설명한 4가지 정보를 필요로 하는 반면, RARP는 IP 주소만 얻을 수 있음
   
   
이러한 RARP의 두 가지 약점을 극복하기 위해 만들어진 클라이언트-서버 프로토콜이 `BOOTP`다.

BOOTP의 특징은 다음과 같다.

1. 클라이언트-서버 프로그램이므로, BOOTP 서버는 인터넷  상의 어디에나 존재 가능하다.
2. 컴퓨터가 필요로하는 4가지 정보를 모두 제공한다.

> 그러나, BOOTP는 정적인 설정 프로토콜이다. 

클라이언트가 IP 주소를 요청하면 BOOTP 서버는 클라이언트의 물리 주소와 매핑되는 IP 주소를 테이블에서 검색한다.

이는 클라이언트의 물리 주소와 IP 주소 간의 바인딩이 이미 존재한다는 것을 의미한다.
-> 네트워크 관리자가 사전에 모든 MAC 주소를 등록해야만 사용 가능
(DHCP는 동적 할당 + MAC 주소 없는 장비도 임시로 IP를 받을 수 있음)

**바인딩이 미리 정해지는 것**
이는 컴퓨터가 한 위치에 고정적으로 자리할 때만 적합한 방식이다.

지금처럼 스마트폰이나 노트북을 이동하면서 사용하는 경우 정적 설정 방식은 사용할 수가 없다.

이렇게 `동적인 설정 프로토콜`이 필요한 상황들이 기술이 발전함에 생겨나기 시작했다.
- 호스트가 하나의 물리 망에서 다른 물리 망으로 이동하는 경우
- 호스트가 짧은 시간동안만 임시 IP 주소를 사용하고 싶은 경우

---

# 1️⃣ DHCP

**`BOOTP` 프로콜의 승계자로서, BOOTP와 역방향 호환성을 가지는 프로토콜이다.**

> 🤔왜 역방향 호환성을 가져야 하는가?

🛠️아직 BOOTP 프로토콜을 이용하는 시스템도 계속 이용 가능해야 하기 때문.

# 2️⃣ DHCP 동작 절차

DHCP 클라이언트와 서버는 동일한 네트워크 망에 위치할 수도 있고, 다른 망에 있을 수도 있다.

따라서 각 상황을 별도로 분리하여 생각해야 한다.

## 🔷동일 망

![](https://velog.velcdn.com/images/alstjr971/post/b2533761-03b9-4343-aad7-f84517f989ca/image.png)

보편적이진 않지만, 관리자는 클라이언트와 서버를 동일한 망에 둘 수도 있다.

1. DHCP 서버는 UDP 포트 번호 67번을 passive open 하고, 클라이언트 요청 대기
2. 부팅된 클라이언트 포트 번호 68번을 active open
   - 이 메시지는 목적지 포트 번호 67, 발신지 포트 번호 68을 가지는 UDP 사용자 데이터그램에 캡슐화
   - 그 후 UDP 사용자 데이터그램은 IP 데이터그램에 캡슐화됨
3. 서버는 UDP 목적지 포트 번호 68, 발신지 67로 지정한 뒤, 유니캐스트 매시지나 브로드캐스트 메시지로 클라이언트에게 `응답`
   - 응답이 유니캐스트 형태가 될 수 있는 것은 서버가 클라이언트의 IP 주소를 알기 때문(자신이 할당해줄 IP가 바로 목적지 호스트의 IP 주소)
   - 이는 논리 주소를 물리 주소로 매핑하는 ARP 프로토콜 서비스가 필요 없음을 의미 -> RARP 필요 X

> 그러나 몇몇 시스템은 ARP 과정을 `BYPASS`하는 것을 허용하지 않는다.
- 이 경우에는 브로드캐스트 주소를 사용해야 한다.

## 🔷다른 망

![](https://velog.velcdn.com/images/alstjr971/post/57d74cbd-01ae-479b-835b-90c3ff1f3c3e/image.png)

**클라이언트와 DHCP 서버가 서로 다른 망에 있을 때 문제점**
- DHCP 요청은 클라이언트가 서버의 IP 주소를 모르기 때문에 브로드 캐스트 된다.

그런데, 브로드캐스트된 IP 데이터그램은 어떠한 라우터도 통과하지 못한다.
- WHY? 브로드캐스트는  `직접 브로드캐스트`와 `제한된 브로드캐스트` 두 가지가 존재
  1. 제한된 브로트캐스트 : 동일 네트워크 망에 존재하는 호스트들에게 보냄
    - DHCP 서버는 현재 다른 망에 존재하므로 의미 X
  2. 직접 브로드캐스트 : 특정 네트워크 대역에 존재하는 호스트들에게 보냄
    - DHCP 서버의 네트워크 주소를 모르기 때문에 의미 X
    
> 그럼 어떻게 다른 네트워크에 존재하는 DHCP 서버로부터 IP를 할당받을 수 있는 것일까?

**해결책**

### ☑️중계 에이전트(Relay Agent)

- 중계 에이전트는 DHCP 서버의 유니캐스트 주소를 알고 있다.
- 포트 번호 `67`로 들어오는 브로드캐스트 메시지를 기다린다.
- 이런 패킷을 수신하면 이 메시지를 유니캐스트로 `캡슐화`해 DHCP 서버로 전달해준다.
- DHCP 서버로부터 응답을 받은 중계 에이전트는 DHCP 클라이언트에게 이 응답을 전달해준다.

> 즉, 클라이언트가 67번 포트로 브로드캐스트하면, 중개 에이전트가 이를 감지해 대신 DHCP 서버에 요청하고, 응답을 받고 전달해준다.

## 🔷UDP 포트

> 왜 DHCP 클라이언트는 UDP 포트(68)로 임시 포트를 사용하지 않고  잘 알려진 포트를 사용할까?

클라이언트에 대한 서버의 응답이 브로드캐스트 될 때의 문제점을 방지하기 위함이다.

![](https://velog.velcdn.com/images/alstjr971/post/ab89a711-e9b8-4c7c-b29a-d11f0ad05b11/image.png)

예를 들어 `임시 포트`를 사용하는 상황을 생각해보자.

- 임의의 망에 존재하는 호스트 A가 임의로 선택한 임시 포트 2017을 사용하는 DHCP 클라이언트를 가지고 있다고 가정

- 동일한 망에 존재하는 호스트 B가 우연히 같은 임시 포트 번호 2017을 사용하는 DAYTIME 클라이언트를 가지고 있다고 가정

이 경우, DHCP 서버는 목적지 주소가 FFFFFFFF(16)이고, 목적지 포트 번호가 2017인 브로드캐스트 응답 메시지를 보낸다.

-> DHCP 응답 메시지가 요청하지 않은(잘못된) 클라이언트에게 전달되는 문제가 생긴다.

**💡해결책**
1. 잘 알려진 포트 사용
2. 헤더 내에 트랜잭션 식별자 사용

> 🤔헤더 내에 트랜잭션 식별자를 추가했으니까 임시 포트를 사용해도 클라이언트를 구분할 수 있는거 아닌가❓

해당 임시 포트로 운영체제가 바인딩 해주어야 하는데, 해당 포트가 열려있지 않아 폐기될 수 있고, 또 임시 포트는 다른 포트와 중복될 수 있으므로 기존에 있었던 중복 전달 가능성이 존재한다. 

따라서 잘 알려진 포트 68번 사용 + 트랜잭션 식별자 추가 로 이를 해결한 것.

## 🔷패킷 형식

![](https://velog.velcdn.com/images/alstjr971/post/349a37ce-2cf9-48d7-a41d-ef5b505357e8/image.png)

1. 동작 코드 : 요청이면 1, 응답이면 0
2. 하드웨어 유형 : 이더넷 1
3. 하드웨어 길이 : 이더넷 6
4. 홉 개수 : 패킷이 전달될 수 있는 최대 홉 개수 (TTL이랑은 다르다. count++ 방식) agent1 - agent2 - ..  로 갈 때마다 홉 개수를 기록하고 그 거리를 저장
**5. 트랜잭션 식별자**
   - 클라이언트에 의해서 설정됨
   - 요청에 대한 응답을 확인하기 위해 사용됨
   - 서버는 요청 메시지에 있는 것과 동일한 값을 응답 메시지에 기록
6. 초 단위 경과 시간
  - N개의 요청이 왔을 때 가장 최근의 요청으로 응답하기 위함
7. 플래그
![](https://velog.velcdn.com/images/alstjr971/post/f70a38b1-c112-4805-8816-babdd5fb0f92/image.png)
   - 맨 왼쪽 비트만 사용(나머지 비트는 0)
   - 0 : 유니캐스트
   - 1 : 브로드캐스트
8. 클라이언트 IP 주소
  - 클라이언트가 모른다면 0, 서버가 알고 있다면(첫 요청이 아닌 경우) 지정
9. 상대방 IP 주소
  - DHCP가 클라이언트에게 할당할 IP 주소
  - 클라이언트와 상대방은 결국 같은 사용자는 맞음.
10. 나머지(서버, 게이트웨이, 클라이언트 하드웨어 주소, 서버, 부트 파일이름)


---

# 3️⃣ 설정
> DHCP는 정적 주소 할당과 동적 주소 할당 모두 지원한다.

## 🔹고정 주소 할당

- DHCP 서버는 물리 주소와 IP 주소를 정적으로 바인딩한 데이터베이스를 가지고 있다.
- 이렇게 동작할 경우, 이전에 사용되었다고 소개한 `BOOTP` 과 역방향 호환성을 가진다.


## 🔹동적 주소 할당

- DHCP는 이용 가능한 IP 주소의 `POOL`을 가지는 다른 데이터베이스를 가지고 있다.
- 이 두번째 데이터베이스가 DHCP를 동적으로 만들어 준다.

`동작 절차`
1. DHCP 클라이언트가 DHCP 서버에게 요청하면, 서버는 먼저 자신의 정적 데이터베이스를 확인한다.
2. 이 데이터베이스에 요청된 물리 주소가 존재하면, 대응되는 IP 주소를 반환한다.
3. 만약 위 데이터베이스에서 물리 주소를 못 찾으면, 사용 가능한 IP 풀에서 할당하고 이를 데이터베이스에 추가한다.

> 풀에서 할당된 주소는 `임시 주소`다.
- DHCP 서버는 이 주소를 일정 기간 임대해준다.
- 임대 기간이 끝나게 되면 클라이언트는 이 주소 사용을 그만두거나, 임대를 새로 요청해야 한다.

## 🔹메시지 교환

**DHCP 서버가 N개인 상황**

![](https://velog.velcdn.com/images/alstjr971/post/ae807e54-8073-4fe0-bbbd-56986b9dd6c7/image.png)

DHCP 서버를 찾는 과정을 `DHCP DISCOVER`라고 한다.

해당 요청을 받은 DHCP 서버는 '나 여기 있어!' 라고 응답을 보낸다.

> 🤔그런데 이때 DHCP 서버가 여러 개가 존재 해 클라이언트에게 여러 개의 응답이 오면 어떻게 해야 할까❓

클라이언트는 이 중 하나의 DHCP 서버를 골라, 그 서버한테 `DHCP REQUEST` 요청을 보낸다.

요청을 받은 선택된 DHCP 서버는 `DHCP ACK` 응답으로 IP를 할당해준다.

임시 할당된 IP 주소의 만료 기간이 50% 이하 남았을 때 클라이언트는 DHCP REQUEST를 다시 보내 IP 주소를 재할당 받는다.
