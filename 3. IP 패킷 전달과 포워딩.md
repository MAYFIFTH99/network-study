# 1. 전달

네트워크 계층은 하부의 물리 네트워크에 의해 패킷이 처리되는 과정을 감독한다.

- 데이터 링크 & 물리 계층에서의 과정을 관리, 감독

이 처리 과정을 `패킷의 전달` (delivery of a packet) 라고 부른다.

최종 목적지까지 패킷의 전달은 두 가지 다른 방법을 사용하여 수행된다

1. 직접 전달(direct delivery)
2. 간접 전달(indirect delivery)

- directed broadcast addressing과 direct delivery 를 헷갈리지 말자.
    - 직접 브로드캐스팅 주소 지정 방식은 특정 네트워크에 패킷을 전달하는 것

## 1.1 직접 전달

![](https://velog.velcdn.com/images/alstjr971/post/59b50c54-69b3-44cb-895e-5dc64cfefbf7/image.png)


- A → B 로 데이터를 전달할 때, 중간 노드를 거치지 않고 바로 B로 직빵
- 같은 네트워크에 있는 장치끼리는 직접 패킷을 주고 받음
- 즉, IP 패킷에 적힌 Destination IP 주소로 전달

## 1.2 간접 전달

![](https://velog.velcdn.com/images/alstjr971/post/f49e3f6a-4e62-4adf-9e2a-0343951e3e8c/image.png)


- A → B 로 데이터를 전달할 때, 중간 라우터들을 거쳐서 B에 전달하는 방법

<aside>
💡

그럼 Source 호스트는 자신이 직접 전달을 하는지, 간접 전달을 하는 지 알 수 있나?

- 알 수 있다.
- HOW ?
    - Source IP 주소의 네트워크 주소와 Destination IP 주소의 네트워크 주소를 네트워크 마스크(서브넷 마스크)를 이용해 구해 비교
    - 만약 같다면 동일 네트워크에 있다는 것임으로 → 직접 전달
    - 다르다면 게이트웨이(라우터)를 거쳐서 전달
</aside>

---

# 2. 포워딩

> 패킷을 목적지로 가는 경로 상에 놓는 것
> 
- Plcae the packet in its route

오늘날의 Internet은  

- 링크(네트워크)들의 조합으로 이루어져 있으므로,
- 포워딩은
    - 마지막 목적지가 될 수도 있고,
    - 중간 연결 장치(라우터 등)가 될 수도 있는
- 다음 홉으로 패킷을 전달하는 것을 의미한다.

<aside>
💡

IP 프로토콜은 원래 비 연결형으로 설계되었으나, 오늘날의 IP는 연결 지향 프로토콜로 사용되는 경향이 있다.

- 비 연결형 → 신뢰성  X
</aside>

**🤔Delivery와 Forwarding의 차이❓**

👉 Delivery는 경로를 생각하지 않고, 단순히 전달만 함

👉 Forwarding은 경로를 지정하고 거리를 설정하는 것까지를 의미

![](https://velog.velcdn.com/images/alstjr971/post/517383c7-c5a7-4865-9bd3-4ce201a02313/image.png)


- 포워딩은 Delivery로 완료됨

## 2.1 목적지 주소 기반 포워딩

### 2.1.1 다음 홉 방법(Next-Hop Method)

> 라우팅 테이블은 전체 경로에 대한 정보 대신, 다음 홉의 주소만 저장
> 

![](https://velog.velcdn.com/images/alstjr971/post/5e0791b0-d3ef-4af6-bbb3-89f47625e7fb/image.png)


- Route 컬럼에 어떤 라우터, 호스트들이 올 지 결정하는 것은 최단 경로 알고리즘을 이용해 계산

두 개의 라우팅 테이블 중 위 라우팅 테이블은 거쳐가는 경로가 모두 기입되어 있다.

하지만, 이 경우 거쳐가야 하는 경로가 20개면 20개를 모두 작성해야 하는 비효율 문제가  있다.

따라서 간접 전달 방식으로 바꾸고, 다음 목적지 주소 1개만 작성하는 방법으로 바뀌었다.

---

### 2.1.2 네트워크 지정 방법(Network-Specific Method)

> 같은 네트워크에 연결된 모든 호스트에 대해 각 호스트 별로 엔트리를 갖는 대신에, 목적지 네트워크 주소를 정의하는 엔트리 하나만을 보유
> 

![](https://velog.velcdn.com/images/alstjr971/post/3839a742-6c5d-4f61-9b5b-8b3011b2202e/image.png)


- 목적지의 전체 IP 주소가 아니라 목적지 네트워크 주소를 기반으로 경로를 지정
- 즉, 전체 호스트 주소를 기억하는 대신, 특정 네트워크 주소에 대해 경로를 설정
- 라우터는 목적지 주소를 보고, 그 주소가 속한 네트워크 범위와 일치하는 항목을 찾음(탐색)

<aside>
💡

다음-홉 방식은 라우팅 테이블의 Column 을 줄인거고, 네트워크 지정 방법은 Row 수를 줄인 것

</aside>

---

### 2.1.3 호스트 지정 방법(Host-Specific Method)

> 특정 호스트로 가는 패킷이 특정 라우터를 통해 전달되기를 원할 때 사용
> 

![](https://velog.velcdn.com/images/alstjr971/post/4fce0587-9ddf-4110-b8bf-5c2bc2a2cd5b/image.png)


- 다른 이점을 얻기 위해 효율성을 희생
- Host B 에게 전달할 때는 R3 라는 라우터(홉)을 반드시 거치도록 설정
- R3는 방화벽이 설정되어 있거나, 추가적인 보안 조치가 마련된 네트워크라고 가정
    - 네트워크 보안이 적용된 통신이 하고 싶은 경우
    - 경로를 테스트하고 싶은 경우

---

### 2.1.3 디폴트 방법(Default method)

> 라우팅을 간단하게 만드는 기술 중 하나
> 

![](https://velog.velcdn.com/images/alstjr971/post/d9285a77-cf6b-4985-8c78-16ac0aa1708a/image.png)


- 라우팅 테이블에 해당하는 포워딩 방법이 없는 경우
- 외부로 나가는 패킷으로 간주하고 Default 라우터로 설정한  라우터에 전달(Forwarding)

<aside>
💡

소개한 4가지 방법을 통해 10줄이 안되는 라우팅 테이블로 전 세계 모든 컴퓨터와 통신할 수 있다.

실제 컴퓨터에서 라우팅 테이블을 출력해 보면, 10줄이 안되는 것을 확인할 수 있음

</aside>

---

## **클래스기반 주소지정 방법**에서 서브네팅을 사용하지 않는 경우의 단순화된 포워딩 모듈

![](https://velog.velcdn.com/images/alstjr971/post/3203fec8-3c20-4e7b-b444-ea4962dd0631/image.png)


- 일부 가상 네트워크가 아래와 같다고 가정

![](https://velog.velcdn.com/images/alstjr971/post/5b1fa1d9-c5d9-42ed-89c8-24a5b672553a/image.png)


- R1의 라우팅 테이블을 작성해 보자.

1. A Class 
    1. Network Address : 111.0.0.0/8 
    2. Interface : m0
    3. Next hop : -
2. B Class
    1. Network Address: 145.80.0.0/16
        1. Interface : m1
        2. Next hop : -
    2. Network Address: 170.14.0.0/16
        1. Interface : m2
        2. Next hop : -
3. C Class
    1. Network Address: 192.16.7.0
    2. Interface : m0
    3. Next - hop : 111.15.17.32
4. Default
    1. Next hop : 111.30.31.18,  m0

Q. 라우터 R1이 목적지 주소가 192.16.7.14 인 패킷을 수신했을  때 포워딩하는 과정 

1. 목적지 주소 복사한 주소를 오른쪽으로 28비트 Shift
2. 4bit 값으로 Class 추출 → C Class
3. 네트워크 주소 : 192.16.7.0
4. 라우팅 테이블에 해당 네트워크 주소가 있는지 확인
    1. 있는 경우
        1. Next - hop 주소인 111.15.17.32와 인터페이스 번호 m0 를 함께 ARP 로 전달
    2. 없는 경우
        1. Default 로 포워딩

---

## 클래스기반 주소지정에서 서브네팅을 사용하는 경우 단순화된 포워딩 모듈

![](https://velog.velcdn.com/images/alstjr971/post/e59ff3b4-b381-49bf-a0b5-5441c44a5d43/image.png)


- Class 단위로 라우팅 테이블을 작성하지 않은 것을 확인 가능
1. 목적지 주소 추출
2. 서브넷 마스크를 이용해 서브넷 주소(네트워크 주소) 추출
3. Next-hop 주소와 인터페이스 번호를 갖고 라우팅 테이블 탐색
4. ARP 에 전달

- 아래와 같은 네트워크 부분이 있다고 해보자.

![](https://velog.velcdn.com/images/alstjr971/post/c4bde5a5-fb21-4b8e-8357-1455d04977df/image.png)


1. 사이트 주소는 145.14.0.0/16 이다.
- 145.14.0.0 ~ 145.14.255.255 사이의 목적지 주소는 먼저 인터페이스 m4로 전달되고, 라우터에 의해 최종 목적지 서브넷으로 전달된다.

1. 이 라우터가 어느 네트워크에 연결되어 있는지 모르므로, 인터페이스 m4에는 x.y.z.t/n 이라는 주소를 사용했다.
2. 테이블은 외부로 나갈 패킷을 위하여 Default Entry를 갖고 있다.
- 라우터는 모든 목적지 주소에 대해 /18 서브넷 마스크를 적용하도록 구성되어 있다.

Q. 목적지 주소가 145.14.32.78 인 패킷을 라우터가 수신하였을 때, 패킷이 어떻게 포워딩 되는지 보여라.

1. 서브넷 마스크를 이용해 네트워크 주소를  찾는다
    - 145.14.0.0/18
2. 패킷은 다음 홉 주소 145.14.32.78과 인터페이스 번호 m0을 함께 ARP에게 전달된다.

Q. 145.14.0.0 네트워크 내의 호스트는 주소가 7.22.67.91인 호스트에 패킷을 보내려고 한다. 이때 패킷이 포워딩되는 과정을 보여라.

1. 7.22.67.91의 서브넷 주소를 구한다
    1. 7.0.0.0/8
2. 라우팅 테이블에서 해당 주소가 있는지 찾는다.
    1. 있는 경우
        1. 다음 홉 주소와 인터페이스 번호를 ARP 에게 전달
    2. 없는 경우
        1. 다음 홉 주소를 default router로 하고, 인터페이스 번호를,m4로 하여 ARP에게 전달

---

<aside>
💡

클래스기반 주소지정 방식에서 라우팅 테이블은 3개의 열을 필요로 하지만,

클래스리스 주소지정 방식에서 라우팅 테이블은 적어도 4개의 열을 필요로 한다.

1. 네트워크 주소
2. 마스크
3. 다음 홉 주소
4. 인터페이스 번호
</aside>

![](https://velog.velcdn.com/images/alstjr971/post/e762d603-1cc2-4a9a-806e-4f75ad8f985f/image.png)


클래스기반 주소지정 방식에서는 왜 세 개의 열?

1. 네트워크 주소
2. 다음 홉 주소
3. 인터페이스 번호

즉, 서브넷 마스크(prefix 길이)는 필요 X

<aside>
💡

그리고, 클래스리스 주소지정 방식에서 라우팅 테이블을 작성할 때는 마스크를 기준으로 내림차순 정렬 작성한다.

</aside>

🤔**Why**❓

👉 마스크가 크다 ⇒ 호스트가 구체적이다 ⇒ 여러 번 탐색할 필요가 없다.

만약 오름 차순으로 정렬한다면,

- 192.168.65.2/18 을 목적지 주소로 하는 패킷이 들어왔을 때,

 192.168.0.0/16 → 192.168.64.0/18 

앞에도 해당하고 뒤에도 해당해 의미 없는 탐색을 하는 비효율 문제 발생

| 마스크 | 네트워크 주소 | 다음 홉 | 인터페이스 번호 |
| --- | --- | --- | --- |
| 26 | 180.70.65.192 | - | m2 |
| 25 | 180.70.65.128 | - | m0 |
| 24 | 201.4.22.0 | - | m3 |
| 22 | 201.4.16.0 | - | m1 |
| Default | Default | 180.70.65.200 | m2 |

Q. 180.70.65.140인 패킷 도착 후 포워딩 과정

1. 첫 번째 마스크 /26 적용
    1. 해당 X
2. 두 번째 마스크 /25 적용
    1. 해당 O
    2. 180.70.65.140(다음 홉 주소)과 m0 을 ARP 에 전달
    3. 이 경우 다음 홉 주소가 패킷의 목적지 주소가 된다.

Q. 201.4.22.35인 패킷 도착 후 포워딩 과정

1. /26 적용 → 실패
2. /25 적용 → 실패
3. /24 적용 → 부합
    1. 201.4.22.35 와 m3 을 ARP 에 전달

Q. 18.24.32.78인 패킷 도착 후 포워딩 과정

1. 1,2,3,4 실패
2. Default 라우터에 목적지 주소와 인터페이스 번호를 함께 전달

---

> 라우팅 테이블을 보고 네트워크 토폴리지 그리기
> 

![](https://velog.velcdn.com/images/alstjr971/post/f9aa310e-dc3e-4198-83cf-f18ead7ebc17/image.png)


- 정보 추론
    1. 직접 연결 네트워크 3개
    2. 간접 연결 네트워크 2개
    3. R1 라우터 인터페이스 3개
    4. 라우터 개수 총 4개

![](https://velog.velcdn.com/images/alstjr971/post/fe1d06d4-0f7e-48ac-8cd6-9931d2d4c0af/image.png)
